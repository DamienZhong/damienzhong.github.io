{"meta":{"title":"呆萌钟，做一个不“纯粹”的技术人","subtitle":null,"description":null,"author":"Damien Zhong","url":"http://yoursite.com"},"pages":[{"title":"���ͽ̳�","date":"2018-11-19T10:38:21.000Z","updated":"2018-11-19T10:45:25.217Z","comments":true,"path":"blog/index.html","permalink":"http://yoursite.com/blog/index.html","excerpt":"","text":""},{"title":"工具教程","date":"2018-11-20T10:10:34.000Z","updated":"2018-11-20T10:10:52.304Z","comments":true,"path":"工具教程/index.html","permalink":"http://yoursite.com/工具教程/index.html","excerpt":"","text":""},{"title":"操作系统","date":"2018-11-20T07:25:33.000Z","updated":"2018-11-20T07:26:16.951Z","comments":true,"path":"操作系统/index.html","permalink":"http://yoursite.com/操作系统/index.html","excerpt":"","text":""},{"title":"虚拟化","date":"2018-11-20T06:18:39.000Z","updated":"2018-11-20T06:22:24.439Z","comments":true,"path":"虚拟化/index.html","permalink":"http://yoursite.com/虚拟化/index.html","excerpt":"","text":""},{"title":"java基础","date":"2018-11-14T02:52:43.000Z","updated":"2018-11-19T10:25:32.352Z","comments":true,"path":"javase/index.html","permalink":"http://yoursite.com/javase/index.html","excerpt":"","text":""},{"title":"JVM","date":"2018-11-20T07:14:02.000Z","updated":"2018-11-20T07:15:06.941Z","comments":true,"path":"JVM/index.html","permalink":"http://yoursite.com/JVM/index.html","excerpt":"","text":""}],"posts":[{"title":"【IntelliJ IDEA】自动生成序列化serialVersionUID设置","slug":"【IntelliJ-IDEA】自动生成序列化serialVersionUID设置","date":"2018-11-20T10:18:31.000Z","updated":"2018-11-20T10:18:57.660Z","comments":true,"path":"2018/11/20/【IntelliJ-IDEA】自动生成序列化serialVersionUID设置/","link":"","permalink":"http://yoursite.com/2018/11/20/【IntelliJ-IDEA】自动生成序列化serialVersionUID设置/","excerpt":"","text":"自动生产序列ID前言实体类继承 java.io.Serializable后，需要设置序列化ID，java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。而IDEA，默认是不支持自动生成序列化ID的（我使用的是IDEA2017版本）。 具体设置如上图所示，我们首先打开设置面板：==File &gt; Settings==，然后定位到==Editor &gt; Inspections==,找到==Java==选项，然后点开==Serialization issues==,然后找到==Serializable class without serialVersion==，勾选，然后点击==Apply==应用即可。 效果演示我们新建一个==SerialIDTest==类进行测试，新建之后让该类实现==Serializable==接口，然后键盘按==Alt+Enter==键，弹出如下窗口：鼠标点击==Add ‘SerialVersion’ field==或者直接回车即可自动生成序列化ID，如下效果图：","categories":[{"name":"工具教程","slug":"工具教程","permalink":"http://yoursite.com/categories/工具教程/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://yoursite.com/tags/IntelliJ-IDEA/"}]},{"title":"【IntelliJ IDEA】项目自动添加版权信息设置","slug":"【IntelliJ-IDEA】项目自动添加版权信息设置","date":"2018-11-20T10:17:06.000Z","updated":"2018-11-20T10:17:33.952Z","comments":true,"path":"2018/11/20/【IntelliJ-IDEA】项目自动添加版权信息设置/","link":"","permalink":"http://yoursite.com/2018/11/20/【IntelliJ-IDEA】项目自动添加版权信息设置/","excerpt":"","text":"自动添加项目版权信息设置 标注1：点击工具栏最上方==的File==选项 标注2：选择==Setting==选项 方案一 标注1：新增版权按钮 如上图所示，我们定位到==Editor &gt; Copyright &gt; Copyright Profiles==，如果确定要新增版权信息的话，点击标注1 所示的新型按钮，点击之后弹出版权名输入框，效果图如下： 标注1：版权名输入框（输入自己的版权名） 标注2：确认按钮（确认新增则点击） 如上图所示，我们这里新增一个名为==damienzhong==的版权名，点击OK之后出现如下效果图： 标注1：版权名输入框（在此可以更改版权名） 标注2：版权声明信息文本框（在此输入版权声明信息） 标注3：版权验证按钮 标注4：应用按钮（设置完必须点击，否则设置不生效） 如上图所示，我们按标注的顺序挨个进行操作，然后定位到上一级==Editor &gt; Copyright== 标注1：菜单选项（定位到此） 标注2：默认项目版权（点击下拉框选择你的的版权名） 如上图所示，我们直接点击默认版权的下拉框，在这里我们选择damienzhong这个版权名，选择完之后我们看下图： 标注1：新增版权使用按钮（点击此按钮） 标注2：版权生效域（选择你需要添加版权的区域） 标注3：应用按钮 如上图所示，我们这边先点击+号按钮，然后选择==All==，代表所有区域，然后点击==Apply==按钮，即可生效。生效之后我们新建一个类文件，效果图如下：如上图所示，红框部分就是我们刚才所设置的版权信息。 方案二（方案一不生效用此方法）打开==Setting==选项，定位到==Plugins==,如下图所示： 标注1：选项路径 标注2：浏览器插件仓库查询按钮（点击此按钮） 我们点击标注2的按钮，出现弹框，如下图所示： 标注1：搜索输入框（输入Copyright） 标注2：Copyright插件（选择此插件） 标注3：安装按钮（点击安装） 如上图所示，我们按标注的顺序进行操作，出现如下效果图： 我们点击重启按钮，重启IDEA，重启之后按方案一的操作方式操作一遍即可生效，这边就不再重复演示了。","categories":[{"name":"工具教程","slug":"工具教程","permalink":"http://yoursite.com/categories/工具教程/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://yoursite.com/tags/IntelliJ-IDEA/"}]},{"title":"【IntelliJ IDEA】设置修改字体大小与样式","slug":"【IntelliJ-IDEA】设置修改字体大小与样式","date":"2018-11-20T10:14:48.000Z","updated":"2018-11-20T10:16:01.588Z","comments":true,"path":"2018/11/20/【IntelliJ-IDEA】设置修改字体大小与样式/","link":"","permalink":"http://yoursite.com/2018/11/20/【IntelliJ-IDEA】设置修改字体大小与样式/","excerpt":"","text":"字体修改界面主题字体修改 标注1：点击工具栏最上方的File选项 标注2：选择Setting选项 标注1：重写默认主题字体（必选） 标注2：具体可以修改字体大小的数值 如上图所示，我们定位到==Appearance &amp; Behavior &gt; Appearance==界面，如果确定要修改主题字体大小的话，标注1 所示的==Override default fonts by XXX==为必选项，否则的话，不能修改字体，因为 IntelliJ IDEA 默认是不推荐修改的；标注2 所示的为我们具体可以修改字体大小的数值。在这里，选择Size为 20，演示一下修改后的效果：如上图所示，这是在选择==Size==为 14、点击==Apply==之后的效果，显然界面主题的字体明显都变大了很多。 在这里，有一点需要注意，那就是：有的字体是包含中文的，有的字体则是不包含中文的。一般情况下，使用英文的国家是不需要额外担心乱码问题的，但是我们需要啊！如果我们选择的字体不包含中文的话，很多位置上可能会出现类似于 口口口口口 这样的乱码问题。例如，==Courier New==和==Monaco==就是纯英文字体，而==Microsoft YaHei==就是包含中文的字体。 代码编辑区字体修改与第一张图一样，先进入setting设置弹框==File &gt; Settings==,然后定位到==Editor &gt; Font== 标注1：字体具体大小的数值 标注2：行宽（行与行之间的距离） 如上图所示，我们定位到==Editor &gt; Font==界面，在这里，我们选择Size为 16，演示一下修改后的效果：如上图所示，这是在选择==Size==为 16、点击==Apply==之后的效果，显然编辑区主题的字体明显都变大了很多。 控制台输出字体修改如上图所示，我们定位到==Editor &gt; Color Scheme &gt; Console Font== 标注1：是否替换默认字体大小（需要修改的话就勾选） 标注2：字体具体大小的数值 标注3：行宽（行与行之间的距离） 在这里，我们选择Size为 16，演示一下修改后的效果：如上图所示，这是在选择==Size==为 16、点击==Apply==之后的效果，运行程序后，控制台的输出字体显示大了，也清晰了很多。","categories":[{"name":"工具教程","slug":"工具教程","permalink":"http://yoursite.com/categories/工具教程/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://yoursite.com/tags/IntelliJ-IDEA/"}]},{"title":"【Linux教程学习笔记】21.RPM与YUM","slug":"【Linux教程学习笔记】21-RPM与YUM","date":"2018-11-20T09:38:00.000Z","updated":"2018-11-20T09:38:26.030Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】21-RPM与YUM/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】21-RPM与YUM/","excerpt":"","text":"rpm包的管理介绍一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。 Linux的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。 rpm包的简单查询指令查询已安装的rpm列表rpm –qa|grep xx rpm包名基本格式 一个rpm包名：firefox-45.0.1-1.el6.centos.x86_64.rpm 名称:firefox 版本号：45.0.1-1 适用操作系统: el6.centos.x86_64 表示centos6.x的64位系统 如果是i686、i386表示32位系统，noarch表示通用。rpm包的其它查询指令 rpm -qa :查询所安装的所有rpm软件包 rpm -qa | more rpm -qa | grep X [rpm -qa | grep firefox ] rpm -q 软件包名:查询软件包是否安装 rpm -q firefox rpm -qi 软件包名：查询软件包信息 rpm -qi file rpm -ql 软件包名:查询软件包中的文件 rpm -ql firefox rpm -qf 文件全路径名查询文件所属的软件包 rpm -qf /etc/passwd rpm -qf /root/install.log卸载rpm包基本语法rpm -e RPM包的名称安装rpm包基本语法rpm -ivh RPM包全路径名称参数说明 i=install 安装 v=verbose 提示 h=hash 进度条yumYum 是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。yum的基本指令 查询yum服务器是否有需要安装的软件 yum list|grep xx软件列表 安装指定的yum包 yum install xxx 下载安装","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】20.Linux进程管理","slug":"【Linux教程学习笔记】20-Linux进程管理","date":"2018-11-20T09:36:54.000Z","updated":"2018-11-20T09:37:10.078Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】20-Linux进程管理/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】20-Linux进程管理/","excerpt":"","text":"进程管理基本介绍 在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。 每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。 每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。显示系统执行的进程基本介绍ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数. ps详解 指令：ps –aux|grep xxx ，比如我看看有没有sshd服务 指令说明 System V展示风格 USER：用户名称 PID：进程号 %CPU：进程占用CPU的百分比 %MEM：进程占用物理内存的百分比 VSZ：进程占用的虚拟内存大小（单位：KB） RSS：进程占用的物理内存大小（单位：KB） TT：终端名称,缩写. STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 STARTED：进程的启动时间 TIME：CPU时间，即进程使用CPU的总时间 COMMAND：启动进程所用的命令和参数，如果过长会被截断显示应用实例要求：以全格式显示当前所有的进程，查看进程的父进程。 ps -ef是以全格式显示当前所有的进程 -e 显示所有进程。-f 全格式。 ps -ef|grep xxx 是BSD风格 UID：用户ID PID：进程ID PPID：父进程ID C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高 STIME：进程启动的时间 TTY：完整的终端名称 TIME：CPU时间 CMD：启动进程所用的命令和参数终止进程kill和killall介绍若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。基本语法 kill [选项] 进程号（功能描述：通过进程号杀死进程） killall 进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）常用选项-9 :表示强迫进程立即停止查看进程树pstree基本语法pstree [选项] ,可以更加直观的来看进程信息常用选项 -p :显示进程的PID -u :显示进程的所属用户服务(service)管理服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd 防火墙等)，因此我们又称为守护进程，是Linux中非常重要的知识点。service管理指令 service 服务名[start | stop | restart | reload | status] 在CentOS7.0后不再使用service ,而是systemctl查看服务名 方式1：使用setup -&gt; 系统服务就可以看到。 方式2: /etc/init.d/服务名称服务的运行级别(runlevel)查看或者修改默认级别：vi /etc/inittab Linux系统有7种运行级别(runlevel)：常用的是级别3和5 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有NFS)，不支持网络 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动开机的流程说明chkconfig指令通过chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭基本语法1) 查看服务chkconfig –list|grep xxx2) chkconfig 服务名–list3) chkconfig –level 5 服务名on/off使用细节chkconfig重新设置服务后自启动或关闭，需要重启机器reboot才能生效.动态监控进程top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。基本语法top [选项]选项说明交互操作说明应用实例案例1.监视特定用户 top：输入此命令，按回车键，查看执行的进程。 u：然后输入“u”回车，再输入用户名，即可案例2：终止指定的进程。 top：输入此命令，按回车键，查看执行的进程。 k：然后输入“k”回车，再输入要结束的进程ID号查看系统网络情况netstat基本语法netstat [选项]选项说明 -an 按一定顺序排列输出 -p 显示哪个进程在调用检测主机连接命令ping是一种网络检测检测工具，它主要是用检测远程主机是否正常，或是两部主机间的介质是否为断、网线是否脱落或网卡故障。 如: ping 对方ip地址","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】19.Linux网络配置","slug":"【Linux教程学习笔记】19-Linux网络配置","date":"2018-11-20T09:35:27.000Z","updated":"2018-11-20T09:36:04.758Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】19-Linux网络配置/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】19-Linux网络配置/","excerpt":"","text":"查看网络IP和网关查看虚拟网络编辑器 修改ip地址 查看网关 查看windows环境的中VMnet8网络配置(ipconfig指令) ping 测试主机之间网络连通性基本语法ping 目的主机（功能描述：测试当前服务器是否可以连接目的主机） 应用实例 测试当前服务器是否可以连接百度 ping www.baidu.comlinux网络环境配置第一种方法(自动获取)说明：登陆后，通过界面的来设置自动获取ip 特点：linux启动后会自动获取IP,缺点是每次自动获取的ip地址可能不一样。 第二种方法(指定固定的ip) 说明 直接修改配置文件来指定IP,并可以连接到外网(程序员推荐)，编辑vi /etc/sysconfig/network-scripts/ifcfg-eth0 要求：将ip地址配置的静态的，ip地址为192.168.184.130 ifcfg-eth0文件说明 DEVICE=eth0 #接口名（设备,网卡） HWADDR=00:0C:2x:6x:0x:xx #MAC地址 TYPE=Ethernet #网络类型（通常是Ethemet） UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44 #随机id #系统启动的时候网络接口是否有效（yes/no） ONBOOT=yes IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议） BOOTPROTO=static #IP地址 IPADDR=192.168.184.130 #网关 GATEWAY=192.168.184.2 #域名解析器 DNS1=192.168.184.2 重启网络服务或者重启系统生效 service network restart 、reboot","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】18.Linux网络配置","slug":"【Linux教程学习笔记】18-Linux磁盘分区、挂载","date":"2018-11-20T09:33:43.000Z","updated":"2018-11-20T09:34:15.692Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】18-Linux磁盘分区、挂载/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】18-Linux磁盘分区、挂载/","excerpt":"","text":"分区基础知识mbr分区 最多支持四个主分区 系统只能安装在主分区 扩展分区要占一个主分区 MBR最大只支持2TB，但拥有最好的兼容性gtp分区 支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区） 最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ） windows7 64位以后支持gtpwindows下的磁盘分区Linux分区原理介绍 Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构, Linux中每个分区都是用来组成整个文件系统的一部分。 Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。硬盘说明 Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘 对于IDE硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。 对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。查看所有设备挂载情况命令：lsblk 或者lsblk -f 挂载的经典案例说明下面我们以增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。 如何增加一块硬盘 虚拟机添加硬盘 分区 格式化 挂载 设置可以自动挂载。虚拟机增加硬盘步骤1在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别）！ 虚拟机增加硬盘步骤2 分区命令fdisk /dev/sdb 开始对/sdb分区 m 显示命令列表 p 显示磁盘分区同fdisk –l n 新增分区 d 删除分区 w 写入并退出 说明：开始分区后输入n，新增分区，然后选择p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q。 虚拟机增加硬盘步骤3 格式化磁盘 分区命令:mkfs -t ext4 /dev/sdb1 其中ext4是分区类型虚拟机增加硬盘步骤4挂载: 将一个分区与一个目录联系起来 mount 设备名称挂载目录 例如：mount /dev/sdb1 /newdisk umount设备名称或者挂载目录 例如：umount/dev/sdb1 或者umount/newdisk ==用命令行挂载重启后会失效==虚拟机增加硬盘步骤5 永久挂载: 通过修改/etc/fstab实现挂载 添加完成后执行mount –a 即刻生效磁盘情况查询基本语法df -h查询指定目录的磁盘占用情况基本语法du -h /目录 查询指定目录的磁盘占用情况，默认为当前目录 -s指定目录占用大小汇总 -h 带计量单位 -a 含文件 –max-depth=1 子目录深度 -c 列出明细的同时，增加汇总值","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】17.Linux定时任务调度","slug":"【Linux教程学习笔记】17-Linux定时任务调度","date":"2018-11-20T09:32:42.000Z","updated":"2018-11-20T09:32:59.955Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】17-Linux定时任务调度/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】17-Linux定时任务调度/","excerpt":"","text":"crond 任务调度crontab 进行定时任务的设置。 概述任务调度是指系统在某个时间执行的特定的命令或程序。 任务调度分类 系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等 个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。基本语法crontab [选项]常用选项快速入门 设置任务调度文件：/etc/crontab 设置个人任务调度。执行crontab –e命令。 接着输入任务到调度文件如：/1 * ls –l /etc/ &gt; /tmp/to.txt 意思说每小时的每分钟执行ls –l /etc/ &gt; /tmp/to.txt命令参数细节说明5个占位符的说明特殊符号的说明特定时间执行任务案例crond 相关指令 crontab –r：终止任务调度。 crontab –l：列出当前有那些任务调度 service crond restart [重启任务调度]","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】16.Linux权限管理","slug":"【Linux教程学习笔记】16-Linux权限管理","date":"2018-11-20T09:31:31.000Z","updated":"2018-11-20T09:31:48.942Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】16-Linux权限管理/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】16-Linux权限管理/","excerpt":"","text":"权限的基本介绍ls -l 中显示的内容如下：-rwxrw-r–1 root root 1213 Feb 2 09:39 abc 0-9位说明1) 第0位确定文件类型(d, -, l , c , b)2) 第1-3位确定所有者（该文件的所有者）拥有该文件的权限。—User3) 第4-6位确定所属组（同用户组的）拥有该文件的权限，—Group4) 第7-9位确定其他用户拥有该文件的权限—Other rwx权限详解rwx作用到文件1) [ r ]代表可读(read): 可以读取,查看2) [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.3) [ x ]代表可执行(execute):可以被执行 rwx作用到目录1) [ r ]代表可读(read): 可以读取，ls查看目录内容2) [ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录3) [ x ]代表可执行(execute):可以进入该目录 文件及目录权限实际案例ls -l 中显示的内容如下：-rwxrw-r–1 root root 1213 Feb 2 09:39 abc 10个字符确定不同用户能对文件干什么 第一个字符代表文件类型：文件(-),目录(d),链接(l) 其余字符每3个一组(rwx) 读(r) 写(w) 执行(x) 第一组rwx : 文件拥有者的权限是读、写和执行 第二组rw-: 与文件拥有者同一组的用户的权限是读、写但不能执行 第三组r–: 不与文件拥有者同组的其他用户的权限是读不能写和执行可用数字表示为: r=4,w=2,x=1 因此rwx=4+2+1=7 1 文件：硬连接数或目录：子目录数 root 用户 root 组 1213 文件大小(字节)，如果是文件夹，显示4096字节 Feb 2 09:39 最后修改日期 abc 文件名修改权限-chmod基本说明通过chmod指令，可以修改文件或者目录的权限。 第一种方式：+ 、-、= 变更权限u:所有者g:所有组o:其他人a:所有人(u、g、o的总和)1) chmod u=rwx,g=rx,o=x 文件目录名2) chmod o+w 文件目录名3) chmod a-x 文件目录名 第二种方式：通过数字变更权限 r=4 w=2 x=1 rwx=4+2+1=7 chmod u=rwx,g=rx,o=x 文件目录名 相当于chmod 751 文件目录名修改文件所有者-chown基本介绍 chown newowner file 改变文件的所有者 chown newowner:newgroup file 改变用户的所有者和所有组 -R 如果是目录则使其下所有子文件或目录递归生效修改文件所在组-chgrp基本介绍chgrp newgroup file 改变文件的所有组","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】15.Linux组管理","slug":"【Linux教程学习笔记】15-Linux组管理","date":"2018-11-20T09:30:09.000Z","updated":"2018-11-20T09:30:37.980Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】15-Linux组管理/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】15-Linux组管理/","excerpt":"","text":"基本介绍在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。1) 所有者2) 所在组3) 其它组4) 改变用户所在的组 文件/目录所有者一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。 查看文件的所有者指令：ls –ahl 修改文件所有者指令：chown 用户名文件名 组的创建基本指令groupadd 组名 文件/目录所在组当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。 查看文件/目录所在组基本指令ls –ahl 修改文件所在的组基本指令chgrp 组名文件名 其它组除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。 改变用户所在组在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。 改变用户所在组1) usermod –g 组名用户名2) usermod –d 目录名用户名改变该用户登陆的初始目录。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】14.Linux压缩与解压指令","slug":"【Linux教程学习笔记】14-Linux压缩与解压指令","date":"2018-11-20T09:28:49.000Z","updated":"2018-11-20T09:29:12.184Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】14-Linux压缩与解压指令/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】14-Linux压缩与解压指令/","excerpt":"","text":"gzip/gunzip 指令gzip 用于压缩文件，gunzip 用于解压的 基本语法 gzip 文件（功能描述：压缩文件，只能将文件压缩为*.gz文件） gunzip 文件.gz（功能描述：解压缩文件命令）细节说明当我们使用gzip对文件进行压缩后，不会保留原来的文件。zip/unzip 指令zip 用于压缩文件，unzip 用于解压的，这个在项目打包发布中很有用的基本语法 zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令） unzip [选项] XXX.zip（功能描述：解压缩文件）zip常用选项-r：递归压缩，即压缩目录unzip的常用选项-d&lt;目录&gt; ：指定解压后文件的存放目录tar 指令tar 指令是打包指令，最后打包后的文件是.tar.gz 的文件。基本语法tar [选项] XXX.tar.gz 打包的内容(功能描述：打包目录，压缩后的文件格式.tar.gz)选项说明","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】13.Linux实用搜索查找类指令","slug":"【Linux教程学习笔记】13-Linux实用搜索查找类指令","date":"2018-11-20T09:26:58.000Z","updated":"2018-11-20T09:27:23.773Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】13-Linux实用搜索查找类指令/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】13-Linux实用搜索查找类指令/","excerpt":"","text":"find指令find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。 基本语法find [搜索范围] [选项] 选项说明 locate指令locaate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。 基本语法locate 搜索文件 特别说明由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。 grep指令和管道符号|grep 过滤查找，管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。 基本语法grep [选项]查找内容源文件 常用选项","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】12.Linux实用时间日期类指令","slug":"【Linux教程学习笔记】12-Linux实用时间日期类指令","date":"2018-11-20T09:25:05.000Z","updated":"2018-11-20T09:25:28.420Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】12-Linux实用时间日期类指令/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】12-Linux实用时间日期类指令/","excerpt":"","text":"date指令-显示当前日期基本语法 date（功能描述：显示当前时间） date +%Y（功能描述：显示当前年份） date +%m（功能描述：显示当前月份） date +%d（功能描述：显示当前是哪一天） date “+%Y-%m-%d %H:%M:%S”（功能描述：显示年月日时分秒）date指令-设置日期基本语法date -s 字符串时间cal指令查看日历指令基本语法cal [选项]（功能描述：不加选项，显示本月日历）","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】11.Linux实用文件目录类指令","slug":"【Linux教程学习笔记】11-Linux实用文件目录类指令","date":"2018-11-20T09:23:57.000Z","updated":"2018-11-20T09:24:17.229Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】11-Linux实用文件目录类指令/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】11-Linux实用文件目录类指令/","excerpt":"","text":"pwd 指令基本语法pwd(功能描述：显示当前工作目录的绝对路径) ls指令基本语法ls [选项] [目录或是文件] 常用选项 -a ：显示当前目录所有的文件和目录，包括隐藏的。 -l ：以列表的方式显示信息cd 指令基本语法cd [参数] (功能描述：切换到指定目录)常用参数 绝对路径和相对路径 cd ~ 或者cd ：回到自己的家目录 cd .. 回到当前目录的上一级目录mkdir指令mkdir指令用于创建目录基本语法mkdir [选项] 要创建的目录常用选项-p 创建多级目录rmdir指令rmdir指令删除空目录基本语法rmdir [选项] 要删除的空目录使用细节 rmdir 删除的是空目录，如果目录下有内容时无法删除的。 提示：如果需要删除非空目录，需要使用rm -rf 要删除的目录touch指令touch指令创建空文件基本语法touch 文件名称cp指令cp 指令拷贝文件到指定目录基本语法cp [选项] 源文件路径 目标路径常用选项-r ：递归复制整个文件夹使用细节强制覆盖不提示的方法：\\cprm指令rm 指令移除文件或目录基本语法rm [选项] 要删除的文件或目录常用选项-r ：递归删除整个文件夹-f ：强制删除不提示使用细节强制删除不提示的方法：带上-f 参数即可mv指令mv 移动文件与目录或重命名基本语法 mv oldNameFile newNameFile (功能描述：重命名) mv /temp/movefile /targetFolder (功能描述：移动文件)cat指令cat 查看文件内容基本语法cat [选项] 要查看的文件常用选项-n ：显示行号使用细节cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令| moremore指令more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键，详见操作说明基本语法more 要查看的文件操作说明less指令less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。基本语法less 要查看的文件操作说明echo指令echo输出内容到控制台。基本语法echo [选项] [输出内容]head指令head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容基本语法 head 文件(功能描述：查看文件头10行内容) head -n 5 文件(功能描述：查看文件头5行内容，5可以是任意行数)tail指令tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的前10行内容。基本语法 tail 文件（功能描述：查看文件头10行内容） tail -n 5 文件（功能描述：查看文件头5行内容，5可以是任意行数） tail -f 文件（功能描述：实时追踪该文档的所有更新）&gt; 指令和&gt;&gt; 指令 输出重定向和&gt;&gt; 追加 基本语法 ls -l &gt;文件（功能描述：列表的内容写入文件a.txt中（覆盖写）） ls -al &gt;&gt;文件（功能描述：列表的内容追加到文件aa.txt的末尾） cat 文件1 &gt; 文件2（功能描述：将文件1的内容覆盖到文件2） echo “内容”&gt;&gt; 文件ln 指令软链接也成为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径基本语法ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）细节说明当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。history指令查看已经执行过历史命令,也可以执行历史指令基本语法history（功能描述：查看已经执行过历史命令）","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】10.Linux帮助指令","slug":"【Linux教程学习笔记】10-Linux帮助指令","date":"2018-11-20T09:22:32.000Z","updated":"2018-11-20T09:22:50.694Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】10-Linux帮助指令/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】10-Linux帮助指令/","excerpt":"","text":"帮助指令介绍当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。 man 获得帮助信息基本语法man [命令或配置文件]（功能描述：获得帮助信息） 应用实例man ls help指令基本语法help命令（功能描述：获得shell内置命令的帮助信息） 应用实例help cd 总结虽然上面两个都可以来获取指令帮助，但是需要英语功底，如果英语不太好的，我还是推荐大家直接百度靠谱。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】09.Linux指定运行级别和找回root密码","slug":"【Linux教程学习笔记】09-Linux指定运行级别和找回root密码","date":"2018-11-20T09:21:19.000Z","updated":"2018-11-20T09:21:45.909Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】09-Linux指定运行级别和找回root密码/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】09-Linux指定运行级别和找回root密码/","excerpt":"","text":"指定运行级别基本介绍运行级别说明： 0 ：关机 1 ：单用户【找回丢失密码】 2：多用户状态没有网络服务 3：多用户状态有网络服务 4：系统未使用保留给用户 5：图形界面 6：系统重启 常用运行级别是3和5 ，要修改默认的运行级别可改文件 /etc/inittab的id:5:initdefault:这一行中的数字 运行级别示意图 切换到指定运行级别基本语法init [012356] 应用实例 案例1：通过init 来切换不同的运行级别，比如5-3 ，然后关机。 init 3 –&gt; init 0找回root密码假设我们的root密码忘记了，请问如何找回密码？思路直接进入到单用户模式，然后修改root密码。因为进入单用户模式，root不需要密码就可以登录。操作步骤开机-&gt;在引导时输入 回车键-&gt;看到一个界面输入 e-&gt;看到一个新的界面，选中第二行（编辑内核），再输入e-&gt;在这行最后输入 1，在输入回车键-&gt;再次输入b，这时候就会进入单用户模式。使用passwd指令来修改root密码。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】08.Linux用户管理","slug":"【Linux教程学习笔记】08-Linux用户管理","date":"2018-11-20T09:19:53.000Z","updated":"2018-11-20T09:20:18.238Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】08-Linux用户管理/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】08-Linux用户管理/","excerpt":"","text":"基本介绍用户管理示意图 说明 Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 Linux的用户需要至少要属于一个组添加用户基本语法useradd [选项] 用户名实际案例添加一个用户xm。 特别说明cd 表示change directory，切换目录 细节说明 当创建用户成功后，会自动的创建和用户同名的家目录 也可以通过useradd -d 指定目录新的用户名，给新创建的用户指定家目录 给用户指定或修改密码基本语法passwd 用户名 应用案例给xm指定密码 删除用户基本语法userdel 用户名 应用案例 删除用户xm，但是要保留家目录 userdel 用户名 删除用户以及用户主目录 userdel -r 用户名注意事项在删除用户时，我们一般不会将家目录删除查询用户信息基本语法id 用户名应用实例请查询root 信息 细节说明当用户不存在时，返回无此用户 切换用户介绍在操作Linux中，如果当前用户的权限不够，可以通过su -指令，切换到高权限用户，比如root 基本语法su –切换用户名 应用实例创建一个用户zf, ，指定密码，然后切换到zf. 细节说明 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。 当需要返回到原来用户时，使用exit指令查看当前用户/登录用户基本语法 whoami who am I用户组介绍类似于角色，系统可以对有共性的多个用户进行统一的管理。新增组groupadd 组名删除组groupdel 组名增加用户时直接加上组useradd –g 用户组 用户名操作演示增加一个用户zwj, 直接将他指定到wudang 修改用户的组usermod –g 用户组 用户名 案例演示 用户和组的相关文件/etc/passwd 文件 用户（user）的配置文件，记录用户的各种信息 每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell /etc/shadow 文件 口令的配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志/etc/group 文件 组(group)的配置文件，记录Linux包含的组的信息 每行含义：组名:口令:组标识号:组内用户列表","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】07.Linux开机、重启和用户登录注销","slug":"【Linux教程学习笔记】07-Linux开机、重启和用户登录注销","date":"2018-11-20T09:18:35.000Z","updated":"2018-11-20T09:18:53.969Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】07-Linux开机、重启和用户登录注销/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】07-Linux开机、重启和用户登录注销/","excerpt":"","text":"关机&amp;重启命令基本介绍 shutdown –h now 立该进行关机 shudown -h 1 “hello, 1 分钟后会关机了” shutdown –r now 现在重新启动计算机 halt关机，作用和上面一样. reboot 现在重新启动计算机 sync 把内存的数据同步到磁盘.注意细节不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中用户登录和注销基本介绍 登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用”su -用户名’命令来切换成系统管理员身份. 在提示符下输入logout即可注销用户使用细节 logout 注销指令在图形运行级别无效，在运行级别3下有效. 运行级别这个概念，后面给大家介绍","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】06.vi和vim编辑器","slug":"【Linux教程学习笔记】06-vi和vim编辑器","date":"2018-11-20T09:17:22.000Z","updated":"2018-11-20T09:17:33.092Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】06-vi和vim编辑器/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】06-vi和vim编辑器/","excerpt":"","text":"vi和vim的基本介绍 所有的Linux 系统都会内建vi 文本编辑器。 Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。vi和vim常用的三种模式 正常模式 以vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、贴上』来处理你的文件数据. 插入模式 按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可. 命令行模式 在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim 、显示行号等的动作则是在此模式中达成的.vi和vim三种模式的相互转化图快捷键基本使用1) 拷贝当前行yy , 拷贝当前行向下的5行5yy，并粘贴。2) 删除当前行dd , 删除当前行向下的5行5dd3) 在文件中查找某个单词[命令行下/关键字，回车查找, 输入n 就是查找下一个]4) 设置文件的行号，取消文件的行号.[命令行下: set nu 和:set nonu]5) 编辑/etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg]6) 在一个文件中输入”hello” ,然后又撤销这个动作u7) 编辑/etc/profile 文件，并将光标移动到20行shift+g8) 更多命令请查看vi与vim命令大全vi与vim的快捷键键盘一览图","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】05.远程登录到Linux服务器","slug":"【Linux教程学习笔记】05-远程登录到Linux服务器","date":"2018-11-20T09:00:51.000Z","updated":"2018-11-20T09:15:03.565Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】05-远程登录到Linux服务器/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】05-远程登录到Linux服务器/","excerpt":"","text":"为什么需要远程登录Linux 说明: 公司开发时候，具体的情况是这样的 linux服务器是开发小组共享的. 正式上线的项目是运行在公网的. 因此程序员需要远程登录到centos进行项目管理或者开发. 网络拓扑示意图 远程登录客户端有Xshell5，Xftp5 ,其它的远程工具大同小异.远程登录Linux-Xshell5 Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了中文乱码的问题，是目前程序员首选的软件。 Xshell[1]是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。 Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。 特别说明：如果希望安装好XShell5就可以远程访问Linux系统的话，需要有一个前提，就是Linux启用了SSHD服务，该服务会监听22号端口。 安装过程基本上是下一步，不再讲述。 XShell5的关键配置 远程上传下载文件Xftp5是一个基于windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp 以后，windows 用户能安全地在UNIX/Linux和Windows PC 之间传输文件。 Xftp5的配置和使用连接成功的界面如下： Xftp5中文乱码问题解决方案 按照上图配置之后，只要刷新一下即可解决","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】04.Linux目录结构","slug":"【Linux教程学习笔记】04-Linux目录结构","date":"2018-11-20T08:48:55.000Z","updated":"2018-11-20T08:49:29.159Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】04-Linux目录结构/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】04-Linux目录结构/","excerpt":"","text":"基本介绍linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。 记住一句经典的话：==在Linux世界里，一切皆文件==。 具体的目录结构 /bin [重点] (/usr/bin、/usr/local/bin) 是Binary的缩写, 这个目录存放着最经常使用的命令 /home [重点] 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root [重点] 该目录为系统管理员，也称作超级权限者的用户主目录。 /lib 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc [重点] 所有的系统管理所需要的配置文件和子目录my.conf /usr [重点] 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /boot [重点] 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /srv service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs /tmp 这个目录是用来存放一些临时文件的。 /dev 类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /media [重点] linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt [重点] 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。d:/myshare /opt 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。 /usr/local [重点] 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。 /var [重点] 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。 /selinux [security-enhanced linux] 360 SELinux是一种安全子系统,它能控制程序只能访问特定文件。总结 Linux的目录中有且只有一个根目录/ Linux的各个目录存放的内容是规划好的，不要乱放文件 Linux是以文件的形式管理我们的设备，因此Linux系统，一切皆为文件 Linux的各个文件目录下存放什么内容，必须有一个认识 学习后，脑海中应该有一颗Linux目录树","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】03.VMware和Linux系统(CentOS)安装","slug":"【Linux教程学习笔记】03-VMware和Linux系统-CentOS-安装","date":"2018-11-20T07:39:08.000Z","updated":"2018-11-20T08:46:30.755Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】03-VMware和Linux系统-CentOS-安装/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】03-VMware和Linux系统-CentOS-安装/","excerpt":"","text":"前言学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习 先安装virtual machine ,vm12 再安装Linux (CentOS 6.8) 原理示意图（VM和CentOS的关系）安装VMware 去BIOS里修改设置开启虚拟化设备支持（f2, f10） 安装虚拟机软件（vm12） 参考文章：VMware Workstation 12安装教程（附下载地址与激活码） CentOS安装下载地址 网易镜像：http://mirrors.163.com/centos/6/isos/ 搜狐镜像：http://mirrors.sohu.com/centos/6/isos创建虚拟机 新建虚拟机 新建虚拟机向导 创建虚拟空白光盘 安装Linux系统对应的CentOS版 虚拟机命名和定位磁盘位置 处理器配置，看自己是否是双核、多核 虚拟机处理器数量可以根据自己的机器配置来定，查看电脑的属性即可 设置内存为2GB 内存的大小要根据自己机器的内存来定，建议2G 网络设置NAT ==虚拟机的网络连接三种形式的说明==：123桥接网络：Linux可以和其它的系统通信。但是可能造成ip冲突NAT(网络地址转换方式): linux可以访问外网，不会造成ip冲突。主机模式：你的linux是一个独立的主机，不能访问外网 选择IO控制器类型 选择磁盘类型 123IDE: 老的磁盘类型SCSI: 服务器上推荐使用的磁盘类型，串口。SATA: 也是串口，也是新的磁盘类型。 新建虚拟磁盘 设置磁盘容量 设置磁盘文件存储位置 新建虚拟机向导配置完成 VM设置 加载ISO CentOS配置安装 启动虚拟机 初始化欢迎进入页面 回车选择第一个开始安装配置，此外，在Ctrl+Alt可以实现Windows主机和VM之间窗口的切换 是否对CD媒体进行测试，直接跳过Skip CentOS欢迎页面，直接点击Next 选择简体中文进行安装 选择语言键盘 选择存储设备 给计算机起名 选择时区 设置root密码 （一定记住） 硬盘分区-1 根分区新建 Boot swap分区设置 分区完成 程序引导，直接下一步 现在定制系统软件 Web环境 可扩展文件系统支持 基本系统（不要去勾选java平台，因为后面我们自己需要安装） 应用程序 开发、弹性存储、数据库、服务器可以都不勾，有需要，以后使用中有需要再手动安装 桌面,除了KDE，其他都选就可以了。 语言支持 系统管理、虚拟化、负载平衡器、高可用性可以都不选 完成配置，开始安装CentOS 等待安装完成，等待等待等待等待……20分钟左右 安装完成，重新引导 欢迎引导页面 许可证 创建用户，可以先不创建，用root账户登录就行 时间和日期 Kdump,去掉 重启后用root登录 配置可以上网 使用火狐连接网络，看看是否可以连通","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】02.Linux入门知识","slug":"【Linux教程学习笔记】02-Linux入门知识","date":"2018-11-20T07:35:48.000Z","updated":"2018-11-20T07:37:24.105Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】02-Linux入门知识/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】02-Linux入门知识/","excerpt":"","text":"Linux的介绍 linux怎么读？ 里牛克斯、里尼克斯 ==linux是一个开源、免费的操作系统，其稳定性、安全性==、处理多并发已经得到业界的认可，目前很多企业级的项目都会部署到Linux/unix系统上。 常见的操作系统(win7、IOS、Android、Mac)Linux 吉祥物Linux的创始人Linux主要的发行版Ubuntu(乌班图)、RedHat(红帽)、CentOS、Debain[蝶变]、Fedora、SuSE、OpenSUSELinux和Unix的关系Unix是怎么来的Linux是怎么来的Linux和Unix的关系Linux和Windows比较","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【Linux教程学习笔记】01.Linux学习方法路线","slug":"【Linux教程学习笔记】01-Linux学习方法路线","date":"2018-11-20T07:28:21.000Z","updated":"2018-11-20T07:32:29.312Z","comments":true,"path":"2018/11/20/【Linux教程学习笔记】01-Linux学习方法路线/","link":"","permalink":"http://yoursite.com/2018/11/20/【Linux教程学习笔记】01-Linux学习方法路线/","excerpt":"","text":"Linux课程内容介绍 Linux学习方向 Linux运维工程师 Linux嵌入式开发工程师 在Linux做各种程序开发Linux的应用领域 个人桌面应用领域 此领域是传统Linux应用最薄弱的环节，传统Linux由于界面简单、操作复杂、应用软件少的缺点，一直被windows所压制，但这些年来随着Ubuntu、Fedora等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，Linux在个人桌面领域的占有率在逐渐的提供。 服务器领域 linux在服务器领域的应用是最强的。 linux免费、稳定、高效等特点在这里得到了很好的体现，近些年来linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛。 嵌入式领域 近些年来linux在嵌入式领域的应用得到了飞速的提高 linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高 主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域。以后再物联网中应用会更加广泛。Linux进阶学习路线linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是集群项目都在使用linux,很多软件公司考虑到开发成本都首选linux,在中国软件公司得到广泛的使用。 我个人认为学习linux流程为: 第1阶段：linux环境下的基本操作命令，包括文件操作命令(rm mkdir chmod, chown) 编辑工具使用（vi vim）linux用户管理(useradd userdel usermod)等 第2阶段：linux的各种配置（环境变量配置，网络配置，服务配置） 第3阶段：linux下如何搭建对应语言的开发环境（大数据，JavaEE, Python等） 第4阶段：能编写shell脚本，对Linux服务器进行维护。 第5阶段：能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优。 第6阶段：深入理解Linux系统（对内核有研究），熟练掌握大型网站应用架构组成、并熟悉各个环节的部署和维护方法。Linux的学习方法 高效而愉快的学习 先建立一个整体框架，然后细节 不需要掌握所有的Linux指令，要学会查询手册和百度 先know how ,再know why 计算机是一门”做中学”的学科,不是会了再做，而是做了才会. 适当的囫囵吞枣 Linux不是编程，重点是实际操作，各种常用指令要玩的溜","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"【玩转jvm系列】02.对象探秘","slug":"【玩转jvm系列】02-对象探秘","date":"2018-11-20T07:21:22.000Z","updated":"2018-11-20T07:21:50.124Z","comments":true,"path":"2018/11/20/【玩转jvm系列】02-对象探秘/","link":"","permalink":"http://yoursite.com/2018/11/20/【玩转jvm系列】02-对象探秘/","excerpt":"","text":"注意：本文描述的内容是基于HotSpot虚拟机。 对象的创建对象创建流程图 对象创建流程 虚拟机遇到一条new指令 检查该指令参数在常量池中能否定位到对应类的符号引用 检查该类是否被加载、解析和初始化，如果没有必须先执行加载过程 虚拟机为新生对象分配内存 虚拟机将分配到的内存空间都初始化为零值 虚拟机对对象进行必要的设置（设置对象头） 执行方法，把对象按照程序员的意愿进行初始化对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的布局可以分为三个区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。 对象头包含两部分 第一部分存储对象自身的运行时数据，如HashCode、GC分代年龄、线程持有的锁等。 第二部分是类型指针，即对象指向它的类元数据的指针。如果对象是数组，对象头必须又一块用于记录数组长度的数据。 实例数部分（对象Body部分） 存储代码中所定义的各种类型的字段内容。 无论子父类，都需要记录下路。 对齐填充 对齐填充不是必然存在的，也没有特别含义，仅仅起占位符的作用。 对象的大小必须是8字节的整数倍，不足就通过对齐填充补充。对象的访问定位 目前主流的访问方式有使用句柄和直接指针两种。 使用句柄方式 使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。 直接指针访问方式 直接指针访问的方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 小结虚拟机Sun HotSpot，它使用的是第二种方式进行对象访问的，但从整个软件开发的范围看，各种语言和框架使用句柄来访问的情况也十分常见。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"}]},{"title":"【玩转jvm系列】01.Java虚拟机的基本结构","slug":"【玩转jvm系列】01-Java虚拟机的基本结构","date":"2018-11-20T07:19:45.000Z","updated":"2018-11-20T07:20:46.529Z","comments":true,"path":"2018/11/20/【玩转jvm系列】01-Java虚拟机的基本结构/","link":"","permalink":"http://yoursite.com/2018/11/20/【玩转jvm系列】01-Java虚拟机的基本结构/","excerpt":"","text":"Java虚拟机架构图 Java虚拟机基本结构思维导图 类加载子系统 类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。Java堆 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 对于绝大多数应用，Java堆是Java虚拟机所管理的内存中最大的一块。 Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。 Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。 在实现时，既可以实现成固定大小的，也可以是可扩展的，主流虚拟机都是按照可扩展的（通过-Xmm和-Xms控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展，将会抛出OutOfMemoryError异常。Java虚拟机栈（Java栈） Java虚拟机栈是线程私有的，它的生命周期与线程相同。 每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 Java栈中保存着局部变量、方法参数，同时和Java方法的调用、返回密切相关。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。本地方法栈 本地方法栈与虚拟机栈所发挥的作用非常类似，最大的不同在于虚拟机栈用于Java方法的调用，而本地方法栈则用于本地方法的调用。程序计数器（PC寄存器） 程序计数器是一块较小的内存空间，可以看做是当前线程的字节码的行号指示器。 程序计数器也是每个线程私有的空间，Java虚拟机会为每个Java线程创建程序计数器。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。 此内存区域是唯一一个再Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。方法区 方法区是各个线程共享的内存区域。 用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 它有一个别名叫做Non-Heap(非堆)，用于与Java堆的区分。 可以选择不实现垃圾收集。运行时常量池 运行时常量池是方法区的一部分。 Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生产的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。垃圾回收系统 垃圾回收器可以对方法区、Java堆和直接内存进行回收。 Java堆是垃圾收集器的工作重点。执行引擎 负责执行虚拟机的字节码。直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存以及处理器寻址空间的限制。 访问直接内存的速度会优于Java堆。因此，在读写频繁的场合可能会考虑直接使用直接内存。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"}]},{"title":"VMware安装vmtools实现共享文件与复制","slug":"VMware安装vmtools实现共享文件与复制","date":"2018-11-20T07:03:33.000Z","updated":"2018-11-20T07:04:04.654Z","comments":true,"path":"2018/11/20/VMware安装vmtools实现共享文件与复制/","link":"","permalink":"http://yoursite.com/2018/11/20/VMware安装vmtools实现共享文件与复制/","excerpt":"","text":"vmtools介绍vmtools 安装后，可以让我们在windows下更好的管理vm虚拟机 可以直接粘贴命令在windows 和centos系统之间 可以设置windows和centos的共享文件夹示意图安装vmtools的步骤 进入centos 点击vm菜单的-&gt;install vmware tools centos会出现一个vm的安装包 点击右键解压, 得到一个安装文件 进入该vm解压的目录，该文件在/root/桌面/vmware-tools-distrib/下 安装./vmware-install.pl 全部使用默认设置即可 需要reboot重新启动即可生效设置共享文件夹 为了方便，可以设置一个共享文件夹，比如d:/share windows 和contos 就可以共享文件了，但是在实际公司开发中，文件的上传下载是需要使用远程方式完成的， 远程方式登录，我们后面会具体讲解具体步骤 菜单-&gt;vm-&gt;setting, 如图设置即可 注意:设置选项为always enable , 这样可以读写了 windows和centos可共享d:/share目录 可以读写文件了 在centos的/mnt/hgfs/ 下","categories":[{"name":"虚拟化","slug":"虚拟化","permalink":"http://yoursite.com/categories/虚拟化/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"http://yoursite.com/tags/VMware/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://yoursite.com/tags/虚拟化/"},{"name":"vmtools","slug":"vmtools","permalink":"http://yoursite.com/tags/vmtools/"}]},{"title":"VMware Workstation 12安装教程（附下载地址与激活码）","slug":"VMware-Workstation-12安装教程（附下载地址与激活码）","date":"2018-11-20T07:02:25.000Z","updated":"2018-11-20T07:03:07.342Z","comments":true,"path":"2018/11/20/VMware-Workstation-12安装教程（附下载地址与激活码）/","link":"","permalink":"http://yoursite.com/2018/11/20/VMware-Workstation-12安装教程（附下载地址与激活码）/","excerpt":"","text":"==文章末尾有下载地址和激活码== 下载地址链接: https://pan.baidu.com/s/1mHlcYM44co77ejjFweUuFA 提取码: iua8 激活码5A02H-AU243-TZJ49-GTC7K-3C61N","categories":[{"name":"虚拟化","slug":"虚拟化","permalink":"http://yoursite.com/categories/虚拟化/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"http://yoursite.com/tags/VMware/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://yoursite.com/tags/虚拟化/"}]},{"title":"【Hexo搭建GitPage博客系列】05.新建菜单写文章","slug":"【Hexo搭建GitPage博客系列】05-新建菜单写文章","date":"2018-11-20T07:00:05.000Z","updated":"2018-11-20T07:00:35.962Z","comments":true,"path":"2018/11/20/【Hexo搭建GitPage博客系列】05-新建菜单写文章/","link":"","permalink":"http://yoursite.com/2018/11/20/【Hexo搭建GitPage博客系列】05-新建菜单写文章/","excerpt":"","text":"在Hexo博客系统中, 可以创建菜单、文章、分类、标签。在我们的主题中,菜单和文章需要手动创建,而分类和标签不用手动创建, 创建菜单在博客根目录下打开Git Bash执行如下命令创建一个新的菜单：hexo new page “菜单名”12345$ hexo new page &quot;虚拟化&quot;INFO =========================================INFO Welcome to use Snippet theme for hexoINFO =========================================INFO Created: D:\\DamienGit\\hexo-blog-template\\source\\虚拟化\\index.md 这个指令会在source目录创建一个名为“虚拟化”的文件夹,并在文件夹中创建一个index.md的文件 修改index.md文件，指定type12345---title: 虚拟化date: 2018-11-20 14:18:39type: 虚拟化--- 然后在进入theme文件夹下的主题文件夹里面的_config.yml配置文件，在里面的menu配置选项中新增一个虚拟化菜单选项1234567891011121314## menumenu:- page: home url: / icon: fa-home- page: Java基础 url: /categories/javase/ icon: - page: 博客教程 url: /categories/blog/ icon: - page: 虚拟化 url: /categories/虚拟化/ icon: 本地部署查看效果执行如下命令1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 当你点击新增的菜单的时候可能会报404找不到页面的提示，是因为该目录下没有文章，后续我们指定文章到该菜单下就可以了，往下看即可解决 写文章在博客根目录下打开Git Bash执行如下命令创建文章：hexo new “文章名”12345$ hexo new &quot;【Hexo搭建GitPage博客系列】04.主题更换&quot;INFO =========================================INFO Welcome to use Snippet theme for hexoINFO =========================================INFO Created: D:\\DamienGit\\hexo-blog-template\\source\\_posts\\【Hexo搭建GitPage博客系列】04-主题更换.md 命令执行完毕后可以看到source/_posts/目录下生产了一个刚才我们创建的同名md文件。 打开该文件进行编辑博文123456---title: 【Hexo搭建GitPage博客系列】04.主题更换date: 2018-11-20 14:43:33tags:---博文内容写这里 本地部署查看效果执行如下命令1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 文章指定分类与标签123456title: 【Hexo搭建GitPage博客系列】04.主题更换date: 2018-11-20 14:43:33tags: //标签名 - Hexo - 博客搭建categories: 虚拟化 //分类名","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/博客搭建/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"【Hexo搭建GitPage博客系列】04.主题更换","slug":"【Hexo搭建GitPage博客系列】04-主题更换","date":"2018-11-20T06:43:33.000Z","updated":"2018-11-20T06:59:34.358Z","comments":true,"path":"2018/11/20/【Hexo搭建GitPage博客系列】04-主题更换/","link":"","permalink":"http://yoursite.com/2018/11/20/【Hexo搭建GitPage博客系列】04-主题更换/","excerpt":"","text":"前言前面我们介绍了如何从零开始搭建Hexo博客，并且已经部署到Github上去了。每个人的审美观不一样，所以肯定会有人不喜欢当前的博客主题。接下来，我就为大家介绍如何更换博客主题，让博客变得更加炫酷。 主题切换Hexo的默认主题是landscape，就是刚刚搭建好以后大家看到的样子。 估计很多小伙伴都不太喜欢这样的风格，其实我们可以很容易做一些主题的切换和配置。在Hexo官网提供了很多主题（theme）风格，大家可以挑选自己喜欢的主题进行配置和调整。 在Hexo选择一款你喜欢的主题，点击图片预览demo，点击下面的名字进入该主题的github项目或者官方网站。 这里我们以Next主题为例子，因为这个主题比较成熟，而且有详细的官方文档可以帮助你快速地安装和配置。关于主题的安装和配置很简单，在这里就不演示了，大家可以根据官方文档的指示完成。 安装主题在博客themes目录下右键点击Git Bash，输入以下命令。其他的主题也类似操作。1git clone https://github.com/主题git路径 启用主题修改博客根目录下的_config.yml中的theme属性，将其设置为你下载下来的主题名。1theme: zhutiming 配置主题如果你需要定制主题相关配置显得更加个性化，修改主题目录下的_config.yml配置文件 主题发布分别在Git Bash中执行如下指令发布博客到Github 1hexo clean 1hexo g 1hexo d 部署成功后访问你的地址：http://用户名.github.io，查看效果，有时候有缓存，需要多刷新几次。","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/博客搭建/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"【Hexo搭建GitPage博客系列】03.Hexo博客搭建","slug":"【Hexo搭建GitPage博客系列】03-Hexo博客搭建","date":"2018-11-19T13:43:36.000Z","updated":"2018-11-20T07:00:23.798Z","comments":true,"path":"2018/11/19/【Hexo搭建GitPage博客系列】03-Hexo博客搭建/","link":"","permalink":"http://yoursite.com/2018/11/19/【Hexo搭建GitPage博客系列】03-Hexo博客搭建/","excerpt":"","text":"前言前面我们已经把环境准备好了，接下来我们就可以正式开始我们的博客搭建之路了！ 搭建步骤创建Github仓库 点击创建仓库 项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。如果没有，你可以直接在浏览器输入自己仓库名，在浏览器进行访问，能访问成功说明也OK。初始化博客 安装Hexo，在自己认为合适的地方创个文件夹，然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 输入npm install，安装所需要的组件 输入hexo g，生成博客所需文件 输入hexo s，本地开启服务器，访问该网址，正式体验Hexo 出现如下图就成功了发布博客到Github 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值的获取位置，需要把Clone方式切换成SSH形式，然后复制地址就可以了 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用命令：hexo d -g就可以进行生成部署到Github上了 部署成功后访问你的地址：http://用户名.github.io。那么将看到我们之前在本地部署一样的页面，说明我们就部署成功啦！","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/博客搭建/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"【Hexo搭建GitPage博客系列】02.环境搭建","slug":"【Hexo搭建GitPage博客系列】02-环境搭建","date":"2018-11-19T13:38:40.000Z","updated":"2018-11-20T06:15:13.089Z","comments":true,"path":"2018/11/19/【Hexo搭建GitPage博客系列】02-环境搭建/","link":"","permalink":"http://yoursite.com/2018/11/19/【Hexo搭建GitPage博客系列】02-环境搭建/","excerpt":"","text":"前言Hexo搭建博客需要基于Node.js环境，而且依赖于Git，本篇文章就给大家详细介绍如何搭建环境。 Node环境搭建Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的使用包管理器 npm来管理所有模块的安装、配置、删除等操作，使用起来非常方便，但是想要配置好npm的使用环境还是稍微有点复杂，下面跟着我一起来学习在windows系统上配置NodeJS和NPM吧。 安装NodeJS打开NodeJS的官网，默认的情况主页就提供了Windows版本的下载链接，我们下载LTS版，LTS代表长期支持版本，一般新手建议使用这个版本，因为这个版本使用的人最多，出问题能找到解决方案的概率较大。如下图所示： 下载之后直接打开执行安装操作，直接NEXT 这一步是选择安装哪些模块，默认是全部安装，对于新手来说建议全部安装。点开那个add path选项前面的+号，我们看到，会主动把NodeJS和NPM这两个模块的命令路径添加到系统路径里，对于我们来说就非常方便了。点击next继续下一步，然后确认信息，点击Install开始安装，然后程序就开始复制文件等一系列步骤。一直到安装完毕。 安装完毕后点击finish结束安装进程，然后在桌面图标上点右键，点运行。输入cmd后敲回车，在打开的命令行界面，依次输入命令： node -v npm -v安装Git 访问Git官网下载地址：https://git-scm.com/downloads 选择对应自己操作系统的Git客户端进行下载。 打开下载好的文件，执行安装步骤，一路NEXT 安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 设置本地Git与Github远程SSH后面的操作需要你已经注册了Github账号，如果没有，请先去注册。 输入cd ~/.ssh，检查是否有.ssh的文件夹 如果没有，提示如下图，如果有，删除该文件 然后切换到主用户目录下cd ~，并生成.ssh文件ssh-keygen -t rsa -C “xxxx@xxx.xxx“，执行命令之后连续回车三次 打开.ssh文件中的id_rsa.pub，复制其中的信息 之后进入GitHub，右上角头像下拉选择Settings，弹出界面中左侧栏选择SSH and GPG keys，然后选择New SSH key，将之前复制的id_rsa.pub粘贴到key栏中，title随便取，之后点击Add SSH key就完事儿啦 之后在本地配置好config信息 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/博客搭建/"}]},{"title":"【Hexo搭建GitPage博客系列】01.博客搭建须知","slug":"【Hexo搭建GitPage博客系列】01-博客搭建须知","date":"2018-11-19T13:32:22.000Z","updated":"2018-11-20T06:15:13.083Z","comments":true,"path":"2018/11/19/【Hexo搭建GitPage博客系列】01-博客搭建须知/","link":"","permalink":"http://yoursite.com/2018/11/19/【Hexo搭建GitPage博客系列】01-博客搭建须知/","excerpt":"","text":"背景我想很多接触互联网的人，都想拥有一个自己的个人博客，可以在上面分享工作、学习、生活等等。可能在网上搜到别人的博客的时候，心里也渴望着自己也能在网络上拥有着这样一块小天地。当你点进这篇文章的时候，我可以很肯定的告诉你，你的梦想即将实现！ 博客种类第三方平台依托于第三方平台，比如CSDN、博客园、简书等等用户只要直接在平台注册即可使用。 优点 免费 无技术门槛 傻瓜式操作 平台用户数量大 稳定缺点 对于充满极客精神的人来说，这一点都不酷 受限于平台，不能做二次扩展 发布作品需要遵循平台规则服务器搭建的个人站购买云服务器或者物理机，在服务器中搭建博客环境，搭建对于小白来说比较麻烦。优点 服务器与数据可以自由管理 可以自由开发，想做成什么样就做成什么样 可以拥有独立域名 可以在网站打广告赚取零花钱缺点 收费 有一丁点技术门槛，小白可能会遇到一些波折 服务器没有专门的运维，有被攻击的风险Hexo+GitPage搭建优点 免费 依托于Github，大平台，靠得住 稳定 博客样式可以自由选择，支持二次开发 可以绑定独立域名 无需担心被攻击 数据备份能力极强缺点 Github是国外的，所以国内访问网速不是太稳定 需要掌握Git常用命令总结以上三种方式，我都尝试过了。 第一种第三方平台的方式，我觉得他一点都不酷，所以我只是单纯的把他当成我的备用博客，用于往我的主站引流（可以参考我的CSDN博客）。 第二种方式，起初我是蛮喜欢的。我是在阿里云购买的云虚拟主机，搭建完成之后，刚开始还好，但是后面被人恶意种了挖矿程序，导致服务器的CPU经常处于百分之一百，让网站无法访问，联系了阿里云技术支持，各种叫我升级配置。我知道你们肯定想问，为什么我不自己SSH上去把这挖矿程序干掉。因为云虚拟主机不支持SSH方式连接，要ECS才支持，所以我也很无奈。最终，弃坑，放弃了！ 第三种方式，现在用的就是这种方式，用了段时间感觉还不错，因为自己用github也比较多，所以还是蛮顺手，而且还不花钱，美滋滋。总的来说就是这种方式是第一种和第二种的这种版本，中国人都比较中庸，所以我选了第三种。 那接下来，我就给大家详细的说一说Hexo搭建博客的步骤，希望能帮到大家！","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/博客搭建/"}]},{"title":"【JavaSe必知必会】41-Java内部类","slug":"【JavaSe必知必会】41-Java内部类","date":"2018-11-15T10:35:28.000Z","updated":"2018-11-20T06:15:13.103Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】41-Java内部类/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】41-Java内部类/","excerpt":"","text":"内部类概述把类定义在其他类的内部，这个类就被称为内部类。 举例在类A中定义了一个类B，类B就是内部类。 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有。 外部类要访问内部类的成员，必须创建对象 1234567891011121314151617181920212223242526272829303132/* 内部类： 把类定义在其他类的内部，这个类就被称为内部类。 举例：在类A中定义一个类B，类B就是内部类 内部类的访问特点： A：内部类可以直接访问外部类的成员，包括私有的 B：外部类要访问内部类的成员，必须创建对象*/class Outer&#123; private int num = 10; class Inner&#123; public void show()&#123; System.out.println(num); &#125; &#125; public void method()&#123; //找不到符号 //show(); Inner i = new Inner(); i.show(); &#125;&#125;public class InnerDemo&#123; public static void main(String[] args)&#123; Outer o = new Outer(); &#125;&#125; 内部类位置按照内部类在类中定义的位置不同，可以分为如下两种格式： 成员位置（成员内部类） 局部位置（局部内部类） 12345678910111213141516171819202122232425/* 内部类位置 成员位置：在成员位置定义的类，被称为成员内部类 局部位置：在局部位置定义的类，被称为局部内部类*/class Outer&#123; private int num = 10; //成员位置 /*class Inner&#123; &#125;*/ public void method()&#123; class Inner&#123; &#125; &#125;&#125;public class InnerClassDemo&#123; public static void main(String[] args)&#123; &#125;&#125; 成员内部类外界如何创建对象外部类名.内部类名 对象名 = 外部类对象.内部类对象; 成员内部类的常见修饰符 private 为了保证数据的安全性 static 为了让数据访问更方便 被静态修饰的成员内部类只能访问外部类的静态成员 内部类方法被静态修饰后的方法 静态方法 非静态方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 成员内部类的修饰符： private:为了保证数据的安全性 static:为了方便访问数据 注意：静态内部类访问的外部类数据必须用静态修饰。 案例：我是一个人（人有身体，身体内有心脏） class Body&#123; private class Heart&#123; public void operator()&#123; System.out.println(&quot;心脏支架手术&quot;); &#125; &#125; public void method()&#123; if(如果你是外科医生)&#123; Heart h = new Heart(); h.operator(); &#125; &#125; &#125; 按照我们刚才的讲解，来使用一下。 Body.Heart bh = new Body().new Heart(); bh.operator(); //加了private之后，就不能被访问了，那么，怎么玩呢？ Body b = new Body(); b.method();*/class Outer&#123; private int num = 10; private static int num2 = 100; public static class Inner&#123; public void show()&#123; //System.out.println(num); System.out.println(num2); &#125; public static void show2()&#123; //System.out.println(num); System.out.println(num2); &#125; &#125;&#125;public class InnerClassDemo3&#123; public static void main(String[] args)&#123; //Outer.Inner oi = new Outer().new Inner(); //oi.show(); //oi.show2(); //成员内部类被静态修饰后的访问方式： //格式：外部类名.内部类名 对象名 = new 外部类名.内部类名 Outer.Inner oi = new Outer.Inner(); oi.show(); oi.show2(); Outer.Inner.show2(); &#125;&#125; 局部内部类 可以直接访问外部类的成员 可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能 局部内部类访问局部变量的注意事项： 必须被final修饰 为什么呢？ 因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从对内存中消失，还要使用那个变量。为了让数据还能继续被使用，就用final修饰，这样，在堆内存里面存储的其实是一个常量值。通过反编译工具可以看一下。 123456789101112131415161718192021222324252627282930313233343536/* 局部内部类： A:可以直接访问外部类的成员 B:在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能 局部内部类访问局部变量的注意事项？ A：局部内部类访问局部变量必须用final修饰 B：为什么呢？ 局部变量是随着方法的调用而调用，随着调用完毕而消失。 而对内存的内容并不会立即消失。所以，我们加final修饰。 加如final修饰后，这个变量就成了常量，既然是常量，你消失了， 我在内存中存储的是数据20，所以，我还是有数据在使用的。*/class Outer&#123; private int num = 10; public void method()&#123; int num2 = 20; class Inner&#123; public void show()&#123; System.out.println(num); System.out.println(num2); &#125; &#125; Inner i = new Inner(); i.show(); &#125;&#125;public class InnerClassDemo4&#123; public static void main(String[] args)&#123; Outer o = new Outer(); o.method(); &#125;&#125; 匿名内部类 就是内部类的简化写法 前提：存在一个类或者接口 这里的类可以是具体类也可以是抽象类 格式： new 类名或者接口名(){重写方法} 本质： 是一个继承了类或者实现了接口的子类匿名对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* 匿名内部类： 就是内部类的简化写法。 前提：存在一个类或者接口 这里的类可以是具体的类也可以是抽象类。 格式： new 类名或者接口名()&#123; 重写方法; &#125; 本质是什么呢？ 是一个继承了该类或者实现了该接口的子类匿名对象*/interface Inter&#123; public abstract void show(); public abstract void show2();&#125;class Outer&#123; public void method()&#123; //一个方法的时候 /*new Inter()&#123; public void show()&#123; System.out.println(&quot;show&quot;); &#125; public void show()2&#123; System.out.println(&quot;show&quot;); &#125; &#125;.show(); */ //两个方法的时候 /*new Inter()&#123; public void show()&#123; System.out.println(&quot;show&quot;); &#125; public void show2()&#123; System.out.println(&quot;show&quot;); &#125; &#125;.show(); new Inter()&#123; public void show()&#123; System.out.println(&quot;show&quot;); &#125; public void show2()&#123; System.out.println(&quot;show&quot;); &#125; &#125;.show2(); */ //如果接口或类有很多个方法，就很麻烦 //那么，如何改进呢？ Inter i = new Inter()&#123;//多态 public void show()&#123; System.out.println(&quot;show&quot;); &#125; public void show2()&#123; System.out.println(&quot;show&quot;); &#125; &#125;; i.show(); i.show2(); &#125;&#125;public class InnerClassDemo5&#123; public static void main(String[] args)&#123; Outer o = new Outer(); o.method(); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】40-Java权限修饰符","slug":"【JavaSe必知必会】40-Java权限修饰符","date":"2018-11-15T10:34:38.000Z","updated":"2018-11-19T10:25:32.348Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】40-Java权限修饰符/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】40-Java权限修饰符/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435/* 权限修饰符： 本类 同一个包下（子类和无关系） 不同包下（子类） 不同包下（无关系） private Y 默认 Y Y protected Y Y Y public Y Y Y Y*/package com.damien;public class Father&#123; private void show()&#123; System.out.println(&quot;show&quot;); &#125; void show2()&#123; System.out.println(&quot;show2&quot;); &#125; protected void show3()&#123; System.out.println(&quot;show3&quot;); &#125; public void show4()&#123; System.out.println(&quot;show4&quot;); &#125; public static void main(String[] args)&#123; Father f = new Father(); f.show(); f.show2(); f.show3(); f.show4(); &#125;&#125; 类及其组成可以用的修饰符类 默认、public、final、abstract 我们自己定义：public居多成员变量 四种权限修饰符均可，final,static 我们自己定义：private居多构造方法 四种权限修饰符均可，其他不可 我们自己定义：public居多成员方法 四种权限修饰符均可，final,static,abstract 我们自己定义：public居多 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 修饰符： 权限修饰符：private,默认的,protected,public 状态修饰符：static,final 抽象修饰符：abstract 类： 权限修饰符：默认的,public 状态修饰符：final 抽象修饰符：abstract 用的做多的就是：public 成员变量： 权限修饰符：private,默认的,protected,public 状态修饰符：static,final 用的做多的就是：private 构造方法： 权限修饰符：private,默认的,protected,public 用的做多的就是：public 成员方法： 权限修饰符：private,默认的,protected,public 状态修饰符：static,final 抽象修饰符：abstract 用的做多的就是：public 除此以外的组合规则： 成员变量：public static final 成员方法：public static public abstract public final*/public class Demo&#123; //成员变量 private int x = 10; int y = 20; protected int z = 30; public int a = 40; public final int b = 50; public static int c = 60; public static final int d = 70; //此处不允许使用修饰符abstract //abstract int e = 80; //构造方法 private Demo()&#123;&#125; Demo(String name)&#123;&#125; protected Demo(String name,int age)&#123;&#125; public Demo(String name,int age,String sex)&#123;&#125; //public static Demo()&#123;&#125; //public final Demo()&#123;&#125; //public abstract Demo()&#123;&#125; //成员方法 //static void show()&#123;&#125; //abstract void show(); final void show()&#123;&#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】39-java包package详解","slug":"【JavaSe必知必会】39-java包package详解","date":"2018-11-15T10:33:31.000Z","updated":"2018-11-19T10:25:32.346Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】39-java包package详解/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】39-java包package详解/","excerpt":"","text":"包的概述 其实就是文件夹 作用：对类进行分类管理 包的划分: 举例 学生的增加、删除、修改、查询 老师的增加、删除、修改、查询 以及一会可能出现的其他的类的增加、删除、修改、查询 基本的划分：按照模块和功能分包的定义 package 包名; 多级包用.分开即可注意事项 package语句必须是程序的第一条可执行的代码 package语句在一个Java文件中只能有一个 如果没有package，默认表示无包名带包的类的编译和运行手动式 javac编译当前类文件 手动建立包对应的文件夹 把a步骤的class文件放到b步骤的最终文件夹下 通过Java命令执行。 需要带包名称的执行 java com.damien.PackageDemo自动式 javac编译的时候带上-d即可 javac -d .PackageDemo.java 通过java命令执行。和手动式一样。导包概述不同包下的类之间的访问，我们发现，每次使用不同包下的类的时候，都需要加包的全路径。比较麻烦。这个时候，Java就提供了导包的功能。导包格式import 包名;注意 这种方式导入是到类的名称。 虽然可以最后写*，但是不建议。","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】38-Java接口详解","slug":"【JavaSe必知必会】38-Java接口详解","date":"2018-11-15T10:32:45.000Z","updated":"2018-11-19T10:25:32.345Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】38-Java接口详解/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】38-Java接口详解/","excerpt":"","text":"接口特点 接口用关键字interface表示 格式：interface 接口名{} 类实现接口用implements表示 格式：class 类名 implements 接口名{} 接口不能实例化 那么，接口如何实例化呢？ 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，接口多态 接口的子类 要么是抽象类 要么重写接口中的所有抽象方法接口成员特点 成员变量 只能是常量 默认修饰符public static final 构造方法 没有，因为接口主要是扩展功能的，而没有具体存在 成员方法 只能是抽象方法 默认修饰符public abstract 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 接口成员特点： 成员变量：只能是常量,并且是静态的 默认修饰符：public static final 建议：自己手动给出。 构造方法：接口没有构造方法 成员方法：只能是抽象方法 默认修饰符：public abstract 建议：自己手动给出。 所有的类都默认继承自一个类：Object 类Object是类层次结构的根类。每个类都使用Object作为超类。*/interface Inter&#123; public int num = 10; public final int num2 = 20; public static final int num3 = 30; // 需要&lt;标识符&gt; //public Inter()&#123;&#125; //接口抽象方法不能带有主体 //public void show()&#123;&#125; void show();&#125;//接口名+Impl这种格式是接口的实现类格式/*class InterImpl implements Inter&#123; public InterImpl()&#123; super(); &#125;&#125;*/class InterImpl extends Object implements Inter&#123; public InterImpl()&#123; super(); &#125; void show()&#123;&#125;&#125;public class InterfaceDemo2&#123; public static void main(String[] args)&#123; //创建对象 Inter i = new InterImpl(); System.out.println(i.num); System.out.println(i.num2); System.out.println(&quot;---------------------&quot;); //i.num = 100;//无法为最终变量num分配值 //i.num2 = 200;//无法为最终变量num2分配值 //System.out.println(i.num); //System.out.println(i.num2); System.out.println(Inter.num); System.out.println(Inter.num2); System.out.println(Inter.num3); &#125;&#125; 抽象类和接口的区别 成员区别 抽象类 变量，常量；又抽象方法；抽象方法；非抽象方法 接口 常量；抽象方法 关系区别 类与类 继承，单继承 类与接口 实现，单实现，多实现 接口与接口 继承，单继承，多继承 设计理念 抽象类 呗继承体现的是：“is a”的关系。共性功能 接口 被实现体现的是：“like a”的关系，扩展功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 类与类： 继承关系，只能单继承，可以多层继承 类与接口： 实现关系,可以单实现，也可以多实现 接口与接口： 继承关系，可以单继承，也可以实现多继承,可以多层继承*/interface Father&#123; public abstract void show();&#125;interface Mother extends NaiNai&#123; public abstract void show2();&#125;interface NaiNai&#123; public abstract void show3();&#125;interface Sister extends Father,Mother&#123; &#125;class Son implements Father,Mother&#123; public void show()&#123; System.out.println(&quot;show Son&quot;); &#125; public void show2()&#123; System.out.println(&quot;show2 Son&quot;); &#125; public void show3()&#123; System.out.println(&quot;show3 Son&quot;); &#125;&#125;public class InterfaceDemo3&#123; public static void main(String[] args)&#123; Son s = new Son(); s.show(); s.show2(); s.show3(); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】37-抽象类","slug":"【JavaSe必知必会】37-抽象类","date":"2018-11-15T10:32:00.000Z","updated":"2018-11-19T10:25:32.343Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】37-抽象类/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】37-抽象类/","excerpt":"","text":"抽象类特点 抽象类和抽象方法必须用abstract关键字修饰 abstract class 类名{} public abstract void eat(); 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 那么，抽象类如何实例化呢？ 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态 抽象类的子类 要么是抽象类 要么重写抽象类中的所有抽象方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 抽象类的概述： 动物不应该定义为具体的东西，而且动物中的吃、睡等也不应该是具体。 我们把一个不是具体的功能称为抽象的功能，而一个类中如果由抽象的功能，该类必须是抽象类。 抽象类的特点： A：抽象类和抽象方法必须用abstract关键字修饰 B：抽象类中不一定有抽象方法，但是有抽象方法的类必须定义为抽象类 C：抽象类不能实例化 因为它不是具体的。 抽象类有构造方法，但是不能实例化。构造方法有什么用？ 用于子类访问父类数据的初始化。 D：抽象的子类 a：如果不想重写抽象方法，该子类是一个抽象类 b：重写所有的抽象方法，这个时候子类是一个具体的类 抽象类的实例化其实是靠具体的子类实现的，是多态的方式。*/abstract class Animal&#123;//抽象类的声明格式 //抽象方法 //public abstract void eat()&#123;&#125;//空方法体，这个会报错，抽象方法不能有主体 public abstract void eat(); public Animal()&#123;&#125;&#125;//子类是抽象类abstract class Dog extends Animal&#123; &#125;//子类是具体类，重写抽象方法class Cat extends Animal&#123; public void eat()&#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125;public class AbstractDemo&#123; public static void main(String[] args)&#123; //创建对象 //Animal是抽象的; 无法实例化 //Animal a = new Animal(); //通过多态的方式 Animal a = new Cat(); a.eat(); &#125;&#125; 抽象类的成员特点 成员变量 可以是变量 也可以是常量 构造方法 有构造方法，但是不能实例化 那么，构造方法的作用是什么呢？ 用于子类访问父类数据的初始化 成员方法 可以有抽象方法，限定子类必须完成某些动作 也可以有非抽象方法，提供代码复用性 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 抽象类的成员特点： 成员变量：既可以是变量，也可以是常量 构造方法：有。 用于子类访问父类数据的初始化 成员方法：既可以是抽象的，也可以是非抽象的 抽象类的成员方法特性： A：抽象方法 强制要求子类做的事情。 B：非抽象方法 子类继承的事情，提高代码复用性*/abstract class Animal&#123; public int num = 100; public final int num2 = 20; public Animal()&#123;&#125; public Animal(String name)&#123;&#125; public abstract void show(); public void method()&#123; System.out.println(&quot;show Animal method&quot;); &#125;&#125;class Dog extends Animal&#123; public void show()&#123; System.out.println(&quot;show Dog&quot;); &#125;&#125;public class AbstractDemo2&#123; public static void main(String[] args)&#123; //创建对象 Animal a = new Dog(); a.num = 200; System.out.println(a.num); //a.num2 = 30; System.out.println(a.num2); System.out.println(&quot;------------------------&quot;); a.show(); a.method(); &#125;&#125; 抽象类注意事项12345678910111213141516171819202122232425262728293031/* 一个类如果没有抽象方法，可不可以定义为抽象类？如果可以，有什么意义？ A:可以 B:不让创建对象 抽象类不能和哪些关键字共存 private 冲突 final 冲突 static 无意义*/abstract class Fu&#123; //非法的修饰符组合: abstract和private //private abstract void show(); // 非法的修饰符组合: abstract和final //final abstract void show(); //非法的修饰符组合: abstract和static/ //static abstract void show(); public static void method()&#123; System.out.println(&quot;method&quot;); &#125;&#125;class Zi extends Fu&#123; public void show()&#123;&#125;&#125;public class AbstractDemo3&#123; public static void main(String[] args)&#123; Fu.method(); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】36-面向对象三大特性之多态","slug":"【JavaSe必知必会】36-面向对象三大特性之多态","date":"2018-11-15T10:31:11.000Z","updated":"2018-11-19T10:25:32.342Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】36-面向对象三大特性之多态/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】36-面向对象三大特性之多态/","excerpt":"","text":"多态概述概述 某一个事物，在不同时刻表现出来的不同状态 举例： 猫可以是猫的类型。猫 m = new 猫(); 同时猫也是动物的一种，也可以把猫称为动物。 动物 d = new 猫(); 多态前提和体现 有继承关系 有方法重写 有父类引用指向子类对象多态案例及成员访问特地多态案例成员访问特点 成员变量 编译看左边，运行看左边 成员方法 编译看左边，运行看右边 静态方法 编译看左边，运行看左边 所以前面我们说静态方法不能算方法重写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* 多态：同一个对象（事物），在不同时刻体现出来的不同状态。 举例： 猫是猫，猫是动物。 水（液体、固体、气体）。 猫 m = new 猫(); 动物 d = new 猫(); 多态的前提： A：要有继承关系 B：要有方法重写 其实没有也是可以的，但是如果没用这个就没有意义。 C：要有父类引用指向子类对象。 父 f = new Zi(); 多态中的成员访问特点： A：成员变量 编译看左边，运行看左边 B：构造方法 创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化。 C：成员方法 编译看左边，运行看右边 D：静态方法 编译看左边，运行看左边 (静态和类相关，算不上重写，所以访问还是左边的) 由于成员方法存在方法重写，所以它运行看右边。*/class Fu&#123; public int num = 100; public void show()&#123; System.out.println(&quot;show Fu&quot;); &#125; public static void function()&#123; System.out.println(&quot;function Fu&quot;); &#125;&#125;class Zi extends Fu&#123; public int num = 1000; public int num2 = 200; public void show()&#123; System.out.println(&quot;show Zi&quot;); &#125; public void method()&#123; System.out.println(&quot;method Zi&quot;); &#125; public static void function()&#123; System.out.println(&quot;function Zi&quot;); &#125;&#125;public class DuoTaiDemo&#123; public static void main(String[] args)&#123; //要有父类引用指向子类对象。 //父 f = new Zi(); Fu f = new Zi(); System.out.println(f.num); //找不到符号 //System.out.println(f.num2); f.show(); //找不到符号 //f.method(); f.function(); &#125;&#125; 多态的好处和弊端多态的好处 提供了程序的维护性（由继承保证） 提供了程序的扩展性（由多态保证） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/* 多态的好处： A：提高了代码的维护性（继承保证） B：提高了代码的扩展性(由多态保证) 猫狗案例*/class Animal&#123; public void eat()&#123; System.out.println(&quot;eat&quot;); &#125; public void sleep()&#123; System.out.println(&quot;sleep&quot;); &#125;&#125;class Dog extends Animal&#123; public void eat()&#123; System.out.println(&quot;狗吃肉&quot;); &#125; public void sleep()&#123; System.out.println(&quot;狗站着睡觉&quot;); &#125;&#125;class Cat extends Animal&#123; public void eat()&#123; System.out.println(&quot;猫吃鱼&quot;); &#125; public void sleep()&#123; System.out.println(&quot;猫趴着睡觉&quot;); &#125;&#125;class Pig extends Animal&#123; public void eat()&#123; System.out.println(&quot;猪吃饭&quot;); &#125; public void sleep()&#123; System.out.println(&quot;猪侧着睡觉&quot;); &#125;&#125;//针对动物操作的工具类class AnimalTool&#123; private AnimalTool()&#123;&#125; /*8public static void useCat(Cat c)&#123; c.eat(); c.sleep(); &#125; public static void useDog(Dog d)&#123; d.eat(); d.sleep(); &#125; public static void usePig(Pig p)&#123; p.eat(); p.sleep(); &#125;*/ public static void useAnimal(Animal a)&#123; a.eat(); a.sleep(); &#125;&#125;public class DuoTaiDemo2&#123; public static void main(String[] args)&#123; //养一只猫 Cat c = new Cat(); c.eat(); c.sleep(); //我特别喜欢猫，又养了一只 Cat c2 = new Cat(); c2.eat(); c2.sleep(); //再一只猫 Cat c3 = new Cat(); c3.eat(); c3.sleep(); System.out.println(&quot;-------------------&quot;); //问题来了，我养了很多只猫，每次创建对象是可以接受的， //但是呢？调用方法，除了对象名不同外，其他代码冗余了。 //AnimalTool.useCat(c); //AnimalTool.useCat(c2); //AnimalTool.useCat(c3); //System.out.println(&quot;-------------------&quot;); //我还喜欢狗，养了只狗 Dog d = new Dog(); //再养一只狗 Dog d2 = new Dog(); /*AnimalTool.useDog(d); AnimalTool.useDog(d2); */ System.out.println(&quot;-------------------&quot;); //我喜欢宠物猪 //定义一个猪类，它要继承自动物，提供两个方法，并且还得再工具类中添加该类方法调用 Pig p = new Pig(); Pig p2 = new Pig(); Pig p3 = new Pig(); /*AnimalTool.usePig(p); AnimalTool.usePig(p2); AnimalTool.usePig(p3);*/ AnimalTool.useAnimal(c); AnimalTool.useAnimal(c2); AnimalTool.useAnimal(c3); AnimalTool.useAnimal(d); AnimalTool.useAnimal(d2); AnimalTool.useAnimal(p); AnimalTool.useAnimal(p2); AnimalTool.useAnimal(p3); &#125; &#125; 多态的弊端 不能访问子类特有功能 那么我们如何才能访问子类特有功能呢？ 多态中的转型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 多态的弊端： 不能使用子类特有功能。 我就想使用子类的特有功能？行不行？ 行 怎么用呢？ A：创建子类对象调用方法。（可以，但是很多时候不合理，而且，太占用内存） B：把父类的引用强制转化为子类的引用。（向下转型） 对象间的转型问题： 向上转型： Fu f = new Zi(); 向下转型： Zi z = (Zi)f;//要求该f必须是能够转换为Zi*/class Fu&#123; public void show()&#123; System.out.println(&quot;show Fu&quot;); &#125;&#125;class Zi extends Fu&#123; public void show()&#123; System.out.println(&quot;show Zi&quot;); &#125; public void method()&#123; System.out.println(&quot;method Zi&quot;); &#125;&#125;public class DuoTaiDemo3&#123; public static void main(String[] args)&#123; Fu f = new Zi(); //f.show(); //f.method(); //创建子类对象 //Zi zi = new Zi(); //zi.show(); //zi.method(); //把子的对象赋值给父亲，但是因为父的引用类型与子的不一致，所以我们需要做个强制类型转化 Zi z = (Zi)f; z.show(); z.method(); &#125;&#125; 多态中的转型问题 向上转型 从子到父 父类引用指向子类对象 向下转型 从父到子 父类引用转为子类对象","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】35-final关键字","slug":"【JavaSe必知必会】35-final关键字","date":"2018-11-15T10:29:48.000Z","updated":"2018-11-19T10:25:32.329Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】35-final关键字/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】35-final关键字/","excerpt":"","text":"final关键字引入final关键字是最终的意思。可以修饰类、成员方法、成员变量。123456789101112131415161718192021222324252627/* 继承的代码体现： 由于继承中方法有一个现象：方法重写。 所以，父类的功能，就会被子类给覆盖。 有些时候，我们不想让子类去覆盖掉父类的功能，只能让他使用。 这个时候，Java就为我们提供了一个关键字：final final:最终的意思。常见的它可以修饰类、方法、变量。*/class Fu&#123; public final void show()&#123; System.out.println(&quot;绝密文件，任何人不能修改&quot;); &#125;&#125;class Zi extends Fu&#123; public void show()&#123; System.out.println(&quot;这是什么鬼，看不懂，撕掉！&quot;); &#125;&#125;public class ZiDemo&#123; public static void main(String[] args)&#123; Zi z = new Zi(); z.show(); &#125;&#125; final关键字修饰特点 修饰类，该类不能被继承。 修饰方法，该方法不能被重写（覆盖）。 修饰变量，变量就变成了常量，只能被赋值一次。123456789101112131415161718192021222324252627282930313233343536373839/* fianl可以修饰类、方法、变量 特点： final可以修饰类，该类不能被继承。 final可以修饰方法，该方法不能被重写（覆盖） final可以修饰变量，该变量不能被重新赋值，因为这个变量其实是常量。 常量： A：字面值常量 &quot;hello&quot;,10,true B：自定义常量 final int x = 10;*///final class Fu //无法从最终Fu进行继承class Fu&#123; public int num = 10; public final int num2 = 20; /*public final void show()&#123; &#125;*/&#125;class Zi extends Fu&#123; public void show()&#123; num = 100; System.out.println(num); num2 = 200;//无法为最终变量num2分配值 System.out.println(num2); &#125;&#125;public class FinalDemo&#123; public static void main(String[] args)&#123; Zi z = new Zi(); z.show(); &#125;&#125; final修饰局部变量的问题12345678910111213141516171819202122232425262728293031323334353637/* 面试题:final修饰局部变量的问题 基本类型：基本类型的值不能发生改变。 引用类型：引用类型的地址值不能发生改变，但是，该对象的堆内存的值是可以改变的。*/class Student&#123; int age = 10;&#125;public class FinalTest&#123; public static void main(String[] args)&#123; //局部变量是基本数据类型 int x = 10; x = 100; System.out.println(x); final int y = 10; //无法为最终变量y分配值 //y = 100; System.out.println(y); System.out.println(&quot;-------------------&quot;); //局部变量是引用类型 Student s = new Student(); System.out.println(s.age); s.age = 100; System.out.println(s.age); System.out.println(&quot;-------------------&quot;); final Student ss = new Student(); System.out.println(ss.age); ss.age = 100; System.out.println(ss.age); //重新分配内存空间 //无法为最终变量ss分配值 ss = new Student(); &#125;&#125; final修饰变量的初始化时机1234567891011121314151617181920212223242526/* final修饰变量的初始化时机 A:被final修饰的变量只能赋值一次。 B:在构造方法完毕前（非静态变量）*/class Demo&#123; int num = 10; final int num2; //final int num2 = 20; &#123; num2 = 10; &#125; public Demo()&#123; num = 100; num2 = 200; &#125;&#125;public class FinalTest2&#123; public static void main(String[] args)&#123; Demo d = new Demo(); System.out.println(d.num); System.out.println(d.num2); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】34-面向对象三大特性之继承","slug":"【JavaSe必知必会】34-面向对象三大特性之继承","date":"2018-11-15T10:28:43.000Z","updated":"2018-11-19T10:25:32.328Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】34-面向对象三大特性之继承/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】34-面向对象三大特性之继承/","excerpt":"","text":"继承概述 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 通过extends关键字可以实现类与类的继承 class 子类名 extends 父类名{} 单独的这个类成为父类，基类或者超类；这多个类可以称为子类或者派生类。 有了继承以后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员。继承的好处 提高了代码的复用性 多个类相同的成员可以放到同一个类中 提高了代码的维护性 如果功能的代码需要修改，修改一处即可 让类与类之间产生了关系，是多态的前提 其实这也是类的一个弊端：类的耦合性很强 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 继承概述： 把多个类中相同的内容给提取出来定义到一个类中。 如何实现继承？ Java提供了关键字：extends 格式： class 子类名 extends 父类名&#123;&#125; 好处： A：提供了代码的复用性 B：提供了代码的维护性 C：让类与类之间产生关系，是多态的前提 *///继承前/*class Student&#123; public void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep()&#123; System.out.println(&quot;睡觉&quot;); &#125;&#125;class Teacher&#123; public void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep()&#123; System.out.println(&quot;睡觉&quot;); &#125;&#125;*///使用继承后class Person&#123; public void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep()&#123; System.out.println(&quot;睡觉&quot;); &#125;&#125;class Student extends Person&#123;&#125;class Teacher extends Person&#123;&#125;public class ExtendsDemo&#123; public static void main(String[] args)&#123; Student s = new Student(); s.eat(); s.sleep(); System.out.println(&quot;-------------&quot;); Teacher t = new Teacher(); t.eat(); t.sleep(); &#125;&#125; 继承的特点 java中只支持单继承，不支持多继承 一个类中只能有一个父类，不可以有多个父类 class SubDemo extends Demo{} //ok class SubDemo extends Demo1,Demo2…//error java支持多层继承（继承体系） class A{} class B extends A{} class C extends B{} 123456789101112131415161718192021222324252627282930313233/* java中继承的特点： A：java中只支持单继承，不支持多继承 有些语言是支持多继承的，格式：extends 类1,类2,... B：java支持多层继承（继承体系）*//*class Father&#123;&#125;class Mother&#123;&#125;class Son extends Father,Mother&#123;&#125;*/class GrandFather&#123; public void show()&#123; System.out.println(&quot;我是你爷爷&quot;); &#125;&#125;class Father extends GrandFather&#123; public void method()&#123; System.out.println(&quot;我是你爸爸&quot;); &#125;&#125;class Son extends Father&#123;&#125;public class ExtendsDemo2&#123; public static void main(String[] args)&#123; Son s = new Son(); s.method(); Father f = new Father(); f.show(); s.show(); &#125;&#125; 继承的注意事项 子类只能继承父类所有非私有的成员（成员方法和成员变量） 其实这也体现了继承的另一个弊端：打破了封装性 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法 不要为了部分功能而去继承 什么时候使用继承呢？ 继承中类之间体现的是：”is a“的关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 继承的注意事项： A：子类只能继承父类所有非私有的成员（成员方法和成员变量） B：子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法 C：不要为了部分功能而去继承 class A&#123; public void show1()&#123;&#125; public void show2()&#123;&#125; &#125; class B&#123; public void show2()&#123;&#125; public void show3()&#123;&#125; &#125; //我们发现B类中出现了和A类一样的show2()方法，所以，我们就用继承体现 class B extends A&#123; public void show3()&#123;&#125; &#125; 这样其实不好，因为这样你不但有了show2()方法，还多show1(),有可能这个show1()不是我们想要的。 那么，我们什么适合考虑使用继承呢？ 继承中类之间体现的是：”is a“的关系 Person Student Teacher 水果 苹果 香蕉 橘子 采用假设法： 如果有两个类A,B,只有她们符合A是B的一种，或者B是A的一种，就可以考虑继承*/class Father&#123; private int num = 10; public int num2 = 20; private void method()&#123; System.out.println(num); System.out.println(num2); &#125; public void show()&#123; System.out.println(num); System.out.println(num2); &#125;&#125;class Son extends Father&#123; public void function()&#123; //System.out.println(num);//num 在 Father 中是 private 访问控制 System.out.println(num2); &#125;&#125;public class ExtendsDemo3&#123; public static void main(String[] args)&#123; //创建对象 Son s = new Son(); //s.method();//子类不能继承父类的私有方法 s.show(); //System.out.println(s.num);//num 在 Father 中是 private 访问控制 s.function(); &#125;&#125; 继承中成员变量的关系在子类方法中访问一个变量 首先在子类局部范围找 然后在子类成员范围找 最后在父类成员范围找（肯定不能访问到父类局部范围） 如果还是没有就报错（不考虑父亲的父亲…） 123456789101112131415161718192021222324252627282930313233343536373839404142/* 类的组成： 成员变量 构造方法 成员方法 现在我们又讲了继承，所以，我们就应该考虑一下，类的组成部分的各自关系 继承中的成员变量的关系： A:子类中的成员变量和父类中的成员变量名称不一样 B:子类中的成员变量和父类中的成员变量名称一样 在子类中访问一个变量的查找顺序： a：在子类方法的局部范围找，有就使用 b：在子类的成员范围找，有就使用 c：在父类的成员范围找，有就使用 d：如果还找不到，会报错 */class Father&#123; public int num = 10; public void method()&#123; int num = 50; &#125;&#125;class Son extends Father&#123; public int num2 = 20; public int num = 30; public void show()&#123; int num = 40; System.out.println(num); System.out.println(num2); //System.out.println(num3);//找不到符号 &#125;&#125;public class ExtendsDemo4&#123; public static void main(String[] args)&#123; Son s = new Son(); s.show(); &#125;&#125; super关键字 super的用法和this很像 this代表本类对应的引用 super代表父类存储空间的标识（可以理解为父类引用）用法 访问成员变量 this.成员变量 super.成员变量 访问构造方法 this(…) super(…) 访问成员方法 this.成员方法() super.成员方法()继承中构造方法的关系 子类中所有的构造方法默认都会访问父类中空参的构造方法 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要完成父类数据的初始化 每一个构造方法的第一条语句默认都是：super() 如果父类中没有构造方法，该怎么办？ 子类通过super去显示调用父类其他的带参的构造方法 子类通过this去调用本类的其他构造方法 本类其他构造方法也必须首先访问了父类的构造方法 一定要注意： super(…)或者this(…)必须出现在第一条语句上 否则，就会有父类数据的多次初始化继承中成员方法的关系 通过子类对象去访问一个方法 首先在子类中找 然后在父类中找 如果还是没有就报错方法重写概述 子类中出现了和父类中一模一样的方法声明，也被称为方法覆盖，方法复写。 使用特点： 如果方法名不同，有就调用对应的方法。 如果方法名相同，最终使用的就是子类自己的。应用当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。注意事项 父类中私有方法不能被重写 子类重写父类方法时，访问权限不能更低 父类静态方法，子类也必须通过静态方法进行重写（其实算不上方法重写）","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】33-代码块详解","slug":"【JavaSe必知必会】33-代码块详解","date":"2018-11-15T10:27:49.000Z","updated":"2018-11-19T10:25:32.326Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】33-代码块详解/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】33-代码块详解/","excerpt":"","text":"代码块在java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块。 局部代码块在方法中出现；限定变量声明周期，及早释放，提供内存利用率。 构造代码块在类中方法外出现；多个构造方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 静态代码块在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 代码块：在Java中，使用&#123;&#125;括起来的代码被称为代码块 根据其位置和声明的不同，可以分为： 局部代码块：局部位置，用于限定变量的生命周期，按顺序执行 构造代码块：在类中的成员位置，用&#123;&#125;括起来的代码，每次调用构造方法都会执行一次，都会先执行构造代码块 作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化 静态代码块：在类中的成员位置，用&#123;&#125;括起来的代码，只不过它用static修饰了，只执行一次 作用：一般是对类进行初始化 面试题： 静态代码块，构造代码块，构造方法的执行顺序？ 静态代码块 -- 构造代码块 -- 构造方法*/class Code&#123; static &#123; int x = 2000; System.out.println(x); &#125; //构造代码块 &#123; int x = 100; System.out.println(x); &#125; //构造方法 public Code()&#123; System.out.println(&quot;code&quot;); &#125; //构造代码块 &#123; int x = 200; System.out.println(x); &#125;&#125;public class CodeDemo&#123; public static void main(String[] argss)&#123; //局部代码块 &#123; int x = 10; System.out.println(x); &#125; // 找不到符号 //System.out.println(x); &#123; int x = 1000; System.out.println(x); &#125; Code c = new Code(); System.out.println(&quot;------------&quot;); Code c2 = new Code(); System.out.println(&quot;------------&quot;); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】32-Java文档的制作与使用","slug":"【JavaSe必知必会】32-Java文档的制作与使用","date":"2018-11-15T10:26:58.000Z","updated":"2018-11-19T10:25:32.325Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】32-Java文档的制作与使用/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】32-Java文档的制作与使用/","excerpt":"","text":"工具类制作工具类中使用静态123456789101112131415161718192021222324252627282930313233343536373839404142/** 我要堆数组进行操作 在同一个文件夹下，类定义在两个文件中和定义在一个文件中其实一样的。*/public class ArrayDemo&#123; public static void main(String[] args)&#123; //定义一个数组 int[] arr = &#123;18,23,6,55,21&#125;; //遍历数组 /*for(int x=0;x&lt;arr.length;x++)&#123; if(x==arr.length)&#123; System.out.println(arr[x]); &#125;else&#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125;*/ //如果我有多个数组都要进行遍历，那么，代码的重复都就很高 //如何改进？用方法改进 //printArray(arr); //测试类的作用：创建其他类的对象，调用其他类的功能 //而我们现在的操作是跟数组相关的，所有，应该把这些操作定义到数组操作类中。 //定义一个数组的操作类 //ArrayTool t = new ArrayTool(); //t.printArray(arr); //方法改进为静态后，就可以直接通过类名调用 ArrayTool.printArray(arr); &#125; /*public static void printArray(int[] arr)&#123; for(int x=0;x&lt;arr.length;x++)&#123; if(x==arr.length)&#123; System.out.println(arr[x]); &#125;else&#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125;*/&#125; 1234567891011121314public class ArrayTool&#123; //把构造方法私有，外界就不能再创建对象了 private ArrayTool()&#123;&#125; public static void printArray(int[] arr)&#123; for(int x=0;x&lt;arr.length;x++)&#123; if(x==arr.length)&#123; System.out.println(arr[x]); &#125;else&#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125;&#125; 制作帮助文档制作工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*** 数组常用操作工具类* @author 呆萌在* @version v1.0*/public class ArrayTool&#123; //把构造方法私有，外界就不能再创建对象了 private ArrayTool()&#123;&#125; /** * 遍历数组 * @param arr */ public static void printArray(int[] arr)&#123; for(int x=0;x&lt;arr.length;x++)&#123; if(x==arr.length)&#123; System.out.println(arr[x]); &#125;else&#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125; /** * 获取指定数值的索引 * @param arr,value * @return int */ public static int getIndex(int[] arr,int value)&#123; int index = -1; for(int x=0;x&lt;arr.length;x++)&#123; if(arr[x]==value)&#123; index = x; break; &#125; &#125; return index; &#125; /** * 获取数组中的最大值 * @param arr * @return int */ public static int getMax(int[] arr)&#123; int max = arr[0]; for(int x=1;x&lt;arr.length;x++)&#123; if(arr[x]&gt;max)&#123; max = arr[x]; &#125; &#125; return max; &#125;&#125; 制作帮助文档（API）javadoc -d 目录 -author -version ArrayTool.java 通过API学习Math类Math类概述Math包含用于执行基本数学运算的方法 Math类特点没有构造方法，因为成员都是静态的 12345678910111213141516171819202122232425/* Math：用于执行基本的数字运算 由于Math类在java.lang包下，所以不需要导包 特点： 没有构造方法，因为它的成员全部是静态的 掌握一个方法： 获取随机数 public static double random();返回带正号的double值，该值大于等于0.0且小于1.0*/public class MathDemo&#123; public static void main(String[] args)&#123; //获取一个随机数 //double d = Math.random(); //System.out.println(d); //我要获取一个1-100之间的随机数 for(int i=0;i&lt;100;i++)&#123; int num = (int)(Math.random()*100)+1; System.out.println(num); &#125; &#125;&#125; 猜数字小游戏1234567891011121314151617181920212223242526272829303132333435363738/* 猜数字小游戏（数据在1-100之间） 分析： A：程序产生一个随机数。（被猜的） B：键盘录入数据。（你猜的） C：把你猜的和被猜的进行比较 a：大了 b：小了 c：猜中了 D：给出多次猜的机会，猜中就结束 */import java.util.Scanner;public class GuessNumber&#123; public static void main(String[] args)&#123; //程序产生一个随机数。（被猜的） int number = (int)(Math.random()*100)+1; //给出多次猜的机会，猜中就结束 while(true)&#123; //键盘录入数据。（你猜的） Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入您要猜的数据（1-100）：&quot;); int guessNumber = sc.nextInt(); //把你猜的和被猜的进行比较 if(guessNumber &gt; number)&#123; System.out.println(&quot;你猜的数据&quot;+guessNumber+&quot;大了&quot;); &#125;else if(guessNumber &lt; number)&#123; System.out.println(&quot;你猜的数据&quot;+guessNumber+&quot;小了&quot;); &#125;else&#123; System.out.println(&quot;恭喜你，猜中了，五百万带回家！！！&quot;); break; &#125; &#125; &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】31-static关键字详解","slug":"【JavaSe必知必会】31-static关键字详解","date":"2018-11-15T10:25:17.000Z","updated":"2018-11-19T10:25:32.322Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】31-static关键字详解/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】31-static关键字详解/","excerpt":"","text":"static关键字的引入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** 定义一个人类 姓名和年龄都是变化的，这个我能接受，因为每个人的性别和年龄都是不同的。 但是，我们现在选取的几个人都是中国人，他们的国籍都是一样的。 一样的国籍，我每次创建对象，在堆内存中都要开辟这样的空间， 浪费了空间。 怎么办？ 针对多个对象有共同的成员变量值的时候，java就提供了一个关键字来修饰：static*/class Person&#123; //姓名 String name; //年龄 int age; //国籍 //String country; static String country; public Person()&#123;&#125; public Person(String name,int age)&#123; this.name = name; this.age = age; &#125; public Person(String name,int age,String country)&#123; this.name = name; this.age = age; this.country = country; &#125; public void show()&#123; System.out.println(&quot;姓名：&quot;+this.name+&quot;,年龄：&quot;+this.age+&quot;,国籍&quot;+this.country); &#125;&#125;public class PersonDemo&#123; public static void main(String[] args)&#123; //创建对象1 Person p1 = new Person(&quot;呆萌钟&quot;,23,&quot;中国&quot;); p1.show(); //创建对象2 //Person p2 = new Person(&quot;迪丽热巴&quot;,24,&quot;中国&quot;); //p2.show(); Person p2 = new Person(&quot;迪丽热巴&quot;,24); p2.show(); //创建对象3 //Person p3 = new Person(&quot;凤姐&quot;,31,&quot;中国&quot;); //p3.show(); Person p3 = new Person(&quot;凤姐&quot;,31); p3.show(); p3.country = &quot;美国&quot;; p3.show(); p1.sho(); p2.show(); &#125;&#125; static内存分析 static关键字可以修饰成员变量和成员方法 static关键字特点 随着类的加载而加载 优先于对象存在 被类的所有对象共享 这也是我们判断是否使用静态关键字的条件 我们可以通过类名调用 12345678910111213141516171819202122232425262728293031/** static的特点：（它可以修饰成员变量，也可以修饰成员方法） A：随着类的加载而加载 回想main方法 B：优先于对象存在 C：被类的所有对象共享 举例： 一个班的学生应该共用一个班级编号。 什么时候该用静态？ 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。 D：可以通过类名调用 其实它本身也可以通过对象调用 推荐使用类名调用 静态修饰的内容一般我们称其为：与类相关的，类成员。*/class Student&#123; //非静态变量 int num = 10; //静态变量 static int num2 = 20;&#125;public class StudentDemo&#123; public static void main(String[] args)&#123; Student s = new Student(); System.out.println(s.num); System.out.println(Student.num2); System.out.println(s.num); &#125;&#125; static关键字注意事项 在静态方法中是没有this关键字的 静态方法只能访问静态的成员变量和静态的成员方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** static关键字注意事项: A：在静态方法中是没有this关键字的 如何理解呢？ 静态是随着类的加载而加载，this是随着对象的创建而存在。 静态比对象先存在。 B：静态方法只能访问静态成员变量和静态成员方法 静态方法： 成员变量：只能访问静态变量 成员方法：只能访问静态成员方法 非静态方法： 成员变量：可以是静态的，也可以是非静态的 成员方法：可以是静态的成员方法，也可是非静态的成员方法 简单记： 静态只能访问静态*/class Teacher&#123; public int num = 10; public static int num2 = 20; public void show()&#123; System.out.println(num);//隐含的告诉你访问的是成员变量 System.out.println(this.num);//明确的告诉你访问的是成员变量 //function(); //function2(); &#125; public static void method()&#123; //无法从静态上下文中引用非静态变量num //System.out.println(num); System.out.println(num2); //无法从静态上下文中引用非静态方法function() //function(); function2(); &#125; public void function()&#123; &#125; public static void function2()&#123; &#125;&#125;public class TeacherDemo&#123; public static void main(String[] args)&#123; //创建对象 Teacher t = new Teacher(); t.show(); System.out.println(&quot;--------------------&quot;); t.method(); &#125;&#125; 静态变量和成员变量的区别所属不同 静态变量属于类，所以也称为类变量 成员变量属于对象，所以也称为实例变量（对象变量）内存中位置不同 静态变量存储于方法区的静态区 成员变量存储于堆内存内存出现时间不同 静态变量随着类的加载而加载，随着类的消失而消失 成员变量随着对象的创建而存在，随着对象的消失而消失调用不同 静态变量可以通过类名调用，也可以通过对象调用 成员变量只能通过对象名调用main方法是静态的public static void main(String[] args){} public被jvm调用，访问权限足够大 static被jvm调用，不用创建对象，直接类名访问 void被jvm调用，不需要给jvm返回值 main一个通用的名字，虽然不是关键字，但是被jvm识别 String[] args以前用于接收键盘录入的 1234567891011121314151617181920212223242526272829/** main方法的格式讲解： public static void main(String[] args)&#123;&#125; public：公共的，访问权限是最大的。由于main方法是被jvm调用，所以权限要够大 static：静态的，不需要创建对象，通过类名就可以。方便jvm调用。 void：方法的返回值是返回给调用者的，而main方法是被jvm调用，返回内容给jvm没有意义。 main：是一个常见的方法入口，很多语言都是用main作为方法入口的。 String[] args：这是一个字符串数组。 有什么用？怎么给值？ 这个东西早期是为了接收键盘录入的数据的。（因为jdk5之前没有Scanner） 格式： java 类名 hello world java*/public class MainDemo&#123; public static void main(String[] args)&#123; //System.out.println(args);//地址值 //System.out.println(args.length);//0 //System.out.println(args[0]);//ArrayIndexOutOfBoundsException //接收数据后 System.out.println(args); System.out.println(args.length); //System.out.println(args[0]); for(int x=0;x&lt;args.length;x++)&#123; System.out.println(args[x]); &#125; &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】30-面向对象三大特性之封装","slug":"【JavaSe必知必会】30-面向对象三大特性之封装","date":"2018-11-15T09:23:30.000Z","updated":"2018-11-19T10:25:32.321Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】30-面向对象三大特性之封装/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】30-面向对象三大特性之封装/","excerpt":"","text":"封装概述封装概述 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** 定义一个女朋友： 成员变量：name,cup,age 成员方法：show() 我们在使用这个案例的过程中，发现了一个问题 通过对象去给成员变量赋值，可以赋值一些非法的数据。 这是不合理的。 我们应该在赋值之前，先对数据进行判断 判断在哪里比较合适呢？ GirlFriendDemo是一个测试类，测试类一般只创建对象，调用方法。 所以，这个判断应该定义在GirlFriend类中 我们在成员变量的位置不可以进行数据判断，因为数据校验，必须要依靠逻辑语句。 有逻辑的这些语句我们应该定义在方法中。 所以，我们应该在GirlFriend类中提供一个方法来进行数据校验 按照我们前面的分析，我们给出了一个方法进行校验。 但是呢，它偏偏不调用方法来赋值，还是直接赋值，这样我们的方法就没用起到作用。 我们就应该要求调用者必须使用我的方法，而不能直接通过调用成员变量赋值。 怎么去强制要求不能直接使用成员变量呢？ 针对这种情况，Java就提供了一个关键字private private:私有的。它可以直接修饰成员变量和成员方法 注意：被private修饰的成员只能在本类中使用 其实，我们描述的就是一个封装思想。 封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。*/class GirlFriend&#123; //姓名 String name; //年龄 private int age; //胸围 String cup; //写一个方法对数据进行校验 /* 返回值类型：void 参数列表：int a */ public void setAge(int a)&#123; if(a&lt;25&amp;&amp;a&gt;16)&#123; age = a; &#125;else&#123; System.out.println(&quot;该年龄不是我的菜！&quot;); &#125; &#125; //成员方法 public void show()&#123; System.out.println(&quot;姓名：&quot;+name); System.out.println(&quot;年龄：&quot;+age); System.out.println(&quot;胸围：&quot;+cup); &#125;&#125;public class GirlFriendDemo&#123; public static void main(String[] args)&#123; //制作一个女朋友 GirlFriend gf = new GirlFriend(); gf.name = &quot;迪丽热巴&quot;; //gf.age = 18; gf.cup = &quot;C&quot;; gf.show(); System.out.println(&quot;----------------------&quot;); gf.name = &quot;罗玉凤&quot;; //gf.age = 38; gf.cup = &quot;A&quot;; gf.show(); System.out.println(&quot;----------------------&quot;); gf.setAge(18); gf.show(); System.out.println(&quot;----------------------&quot;); //gf.age = 48; gf.show(); &#125;&#125; 好处 隐藏实现的细节，提供公共访问方式 提供了代码的复用性 提高安全性封装原则 将不需要对外提供的内容都隐藏起来 把属性隐藏，提供公共方法对其访问 private关键字private关键字 是一个权限修饰符 可以修饰成员（成员变量和成员方法） 被private修饰的成员只能在本类中才能访问 1234567891011121314151617181920212223242526272829303132333435/** private: 是一个权限修饰符 可以修饰成员变量和成员方法 其修饰的成员只能在本类中被访问*/class Demo&#123; //int num = 10; //用private修饰 private int num = 10; public void show()&#123; System.out.println(num); &#125; private void method()&#123; System.out.println(&quot;method...&quot;); &#125; public void function()&#123; method(); &#125;&#125;public class PrivateDemo&#123; public static void main(String args)&#123; Demo d = new Demo(); //不能访问方法私有的成员变量 //System.out.println(d.num); d.show(); //不能访问私有的成员方法 //d.method(); d.function(); &#125;&#125; private最常见的应用 把成员变量用private修饰 提供对应的getXxx()/setXxx()方法 一个标准的案例的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** private最常见的应用: 把成员变量用private修饰 提供对应的getXxx()/setXxx()方法*///定义学生类class Student&#123; //姓名 private String name; //年龄 private int age; //获取姓名值 public String getName()&#123; return name; &#125; //设置姓名值 public void setName(String n)&#123; name = n; &#125; //获取年龄值 public int getAge()&#123; return age; &#125; //设置年龄值 public void setAge(int a)&#123; age = a; &#125;&#125;public class StudentTest&#123; public static void main(String args)&#123; //创建学生对象 Student s = new Student(); //使用成员变量 //错误：被私有修饰了，外界不能直接访问 //System.out.println(s.name + &quot;---&quot; + s.age); System.out.println(s.getName() + &quot;---&quot; + s.getAge()); //给成员变量赋值 //s.name = &quot;范冰冰&quot;; //s.age = 28; //通过方法赋值 s.setName(&quot;范冰冰&quot;); s.setAge(28); System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125;&#125; this关键字 this：代表所在类的对象引用 记住： 方法被哪个对象调用，this就代表那个对象 什么时候使用this呢？ 局部变量隐藏成员变量 其他用法后面和super一起讲解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** 我们曾经约定：起名字要做到见名知意 this:是当前类的对象引用。简单来说，它就代表当前类的一个对象。 注意：谁调用这个方法，在该方法内部的this就代表谁 this的场景： 解决局部变量隐藏成员变量*///定义学生类class Student&#123; //姓名 private String name; //年龄 private int age; //获取姓名值 public String getName()&#123; return name; &#125; //设置姓名值 public void setName(String name)&#123;//name = &quot;范冰冰&quot;; //name = name; //变量的使用规则：就近原则 //这里是类名，目前还没有说过类似的用法，所以这个是有问题的 //这里的调用只能通过对象名 //这个对象如果存在，它应该代表的是Student的一个对象。 //那么，谁能够代表当前类的对象呢？java就提供了一个关键字 this //Student.name = name; this.name = name; &#125; //获取年龄值 public int getAge()&#123; return age; &#125; //设置年龄值 public void setAge(int a)&#123; age = a; &#125;&#125;public class StudentTest&#123; public static void main(String args)&#123; //创建学生对象 Student s = new Student(); //给成员变量赋值 s.setName(&quot;范冰冰&quot;); s.setAge(28); System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125;&#125; 构造方法构造方法作用概述给对象的数据进行初始化 构造方法格式 方法名与类名相同 没用返回值类型，连void都没有 没有具体返回值 12345678910111213141516171819202122232425/** 构造方法： 给对象的数据进行初始化 格式： A:方法名与类名相同 B:没用返回值类型，连void都没有 C:没有具体返回值*/class Student&#123; private String name;//null private int age;//0 public Student()&#123; System.out.println(&quot;这是一个构造方法。。。&quot;); &#125;&#125;public class ConstructDemo&#123; public static void main(String[] args)&#123; //创建对象 Student s = new Student(); System.out.println(s); &#125;&#125; 构造方法注意事项 如果你不提供构造方法，系统会给出默认构造方法 如果你提供了构造方法，系统将不再提供 构造方法也是可以重载的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** 我们一直在使用构造方法，但是，我们却没有定义构造方法，用的是哪里来的呢？ 构造方法的注意事项： A：如果我们没有给出构造方法，系统将自动提供一个无参构造方法。 B：如果我们给出了构造方法，系统将不再提供默认的无参构造方法。 注意：如果我们还想使用无参构造方法，就必须自己给出，建议永远自己给出无参构造方法 给成员变量赋值有两种方式： A：setXxx(); B：构造方法*/class Student&#123; private String name; private int age; public Studesnt()&#123; System.out.println(&quot;这是无参构造方法&quot;); &#125; //构造方法的重载 public Student(String name)&#123; System.out.println(&quot;这是一个带String类型的构造方法&quot;); this.name = name; &#125; public Student(int age)&#123; System.out.println(&quot;这是一个带int类型的构造方法&quot;); this.age = age; &#125; public Student(String name,int age)&#123; System.out.println(&quot;这是一个带两个参数的构造方法&quot;); this.name = name; this.age = age; &#125; public void show()&#123; System.out.println(this.name + &quot;----&quot;+this.age); &#125; &#125;public class ConstructDemo2&#123; public static void main(String[] args)&#123; //创建对象 Student s = new Student(); s.show(); System.out.println(&quot;------------&quot;); //创建对象2 Student s2 = new Student(&quot;呆萌钟&quot;); s2.show(); System.out.println(&quot;------------&quot;); //创建对象3 Student s3 = new Student(18); s3.show(); System.out.println(&quot;------------&quot;); //创建对象4 Student s4 = new Student(&quot;呆萌钟&quot;,18); s4.show(); System.out.println(&quot;------------&quot;); &#125;&#125; 注意：可以通过反编译对比 类的成员方法成员方法其实就是我们前面讲过的方法 方法具体划分 根据返回值 有明确返回值的方法 返回void类型的方法 根据形式参数 无参方法 带参方法一个基本类的标准代码写法类 成员变量 构造方法 无参构造方法 带参构造方法 成员方法 getXxx() setXxx给成员变量赋值的方法 无参构造方法+setXxx() 带参构造方法注意 目前的代码是为了练习的一种标准格式 给成员变量有两种方式，可以只写一种 如果不单独获取数据，可以不写getXxx()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** 一个标准类的最终版 学生类： 成员变量： name,age 构造方法： 无参，带两个参 成员方法： getXxx()/setXxx() show();输出该类的所有成员变量值 给成员变量赋值： A：setXxx(); B：构造方法 输出成员变量的方式“ A：通过getXxx分别获取然后拼接 B：通过调用show()方法*/class Student&#123; //姓名 private String name; //年龄 private int age; public Student()&#123;&#125; public Student(String name,int age)&#123; this.name=name; this.age=age; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name=name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age=age; &#125; //输出所有的成员变量 public void show()&#123; System.out.println(name+&quot;---&quot;+age); &#125;&#125;//测试类public class StudentTest3&#123; public static void main(String[] args)&#123; //方式1给成员变量赋值 Student s1 = new Student(); s1.setName(&quot;呆萌钟&quot;); s1.setAge(24); //输出值 System.out.println(s1.getName()+&quot;---&quot;+s1.getAge()); s1.show(); System.out.println(); //方式2给成员变量赋值 Student s2 = new Student(&quot;呆萌钟2&quot;,18); System.out.println(s2.getName()+&quot;---&quot;+s2.getAge()); s2.show(); &#125;&#125; 类的初始化过程Student s = new Student();在内存中做了哪些事情？ 加载Student.class文件进内存 在栈内存中为s开辟空间 在堆内存中为学生对象开辟空间 对学生对象的成员变量进行默认初始化 对学生对象的成员变量进行显示初始化 通过构造方法对学生对象的成员变量赋值 学生对象初始化完毕，把对象地址赋值给s变量","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】29-匿名对象概述与应用","slug":"【JavaSe必知必会】29-匿名对象概述与应用","date":"2018-11-15T09:22:10.000Z","updated":"2018-11-19T10:25:32.319Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】29-匿名对象概述与应用/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】29-匿名对象概述与应用/","excerpt":"","text":"匿名对象 匿名对象：就是没有名字的对象 是对象的一种简化表示形式 匿名对象的两种使用情况 对象调用方法仅仅一次的时候 作为实际参数传递代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** 注意：一个类文件中可以写多个类，但是只有一个类能带public，而且该类名必须与文件名相同 匿名对象：就是没有名字的对象 匿名对象的应用场景： A：调用方法，仅仅只调用一次的时候 注意：调用多次的时候，不适合 那么，这种匿名对象有什么好处呢？ 有，匿名对象调用完毕就是垃圾。可以被垃圾回收器回收 B：匿名对象可以作为实际参数进行传递*/class Student&#123; public void study()&#123; System.out.println(&quot;我最爱看呆萌钟的视频学习编程了~&quot;); &#125;&#125;class StudentDemo&#123; public void method(Student s)&#123; s.study(); &#125;&#125;public class AnonymousDemo&#123; public static void main(String[] args)&#123; //带名字的调用 Student s = new Student(); System.out.println(s); System.out.println(s); s.study(); s.study(); System.out.println(&quot;----------------------------&quot;); //匿名对象 //new Student(); System.out.println(new Student()); System.out.println(new Student());//这里其实是重新创建了一个对象 //匿名对象调用方法 new Student().study(); new Student().study(); System.out.println(&quot;----------------------------&quot;); //匿名对象作为实际参数传递 StudentDemo sd = new StudentDemo(); //Student ss = new Student(); //sd.method(ss); //匿名对象 sd.method(new Student()); //全用匿名对象 new StudentDemo().method(new Student()); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】28-二维数组经典练习题目","slug":"【JavaSe必知必会】28-二维数组经典练习题目","date":"2018-11-15T09:21:09.000Z","updated":"2018-11-19T10:25:32.318Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】28-二维数组经典练习题目/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】28-二维数组经典练习题目/","excerpt":"","text":"二维数组遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* 需求：二维数组遍历 外循环控制的是二维数组的长度，其实就是一维数组的个数。 内循环控制的是一维数组的长度。*/class Array2Test &#123; public static void main(String[] args) &#123; //定义一个二维数组 int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; //请问谁代表&#123;1,2,3&#125; //arr[0]就是第一个数组 //arr[0] = &#123;1,2,3&#125;; for(int x=0; x&lt;arr[0].length; x++) &#123; System.out.println(arr[0][x]); &#125; System.out.println(&quot;--------------&quot;); for(int x=0; x&lt;arr[1].length; x++) &#123; System.out.println(arr[1][x]); &#125; System.out.println(&quot;--------------&quot;); for(int x=0; x&lt;arr[2].length; x++) &#123; System.out.println(arr[2][x]); &#125; System.out.println(&quot;--------------&quot;); //用循环改进 for(int x=0; x&lt;3; x++) &#123; for(int y=0; y&lt;arr[x].length; y++) &#123; System.out.print(arr[x][y]+&quot; &quot;); &#125; System.out.println(); &#125; System.out.println(&quot;--------------&quot;); //这个时候，注意了，3是我们根据上面的代码得出来的 //但是，它不能针对任何的数组都可以这样 //所以，我们应该想办法改进 //其实，外面的这个循环的长度就是二维数组的长度 for(int x=0; x&lt;arr.length; x++) &#123; for(int y=0; y&lt;arr[x].length; y++) &#123; System.out.print(arr[x][y]+&quot; &quot;); &#125; System.out.println(); &#125; System.out.println(&quot;--------------&quot;); //用方法改进 //调用方法 printArray2(arr); System.out.println(&quot;--------------&quot;); //我们再来一个列数是变化的 int[][] arr2 = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6&#125;&#125;; printArray2(arr2); &#125; /* 需求：遍历二维数组 两个明确： 返回值类型：void 参数列表：int[][] arr */ public static void printArray2(int[][] arr) &#123; for(int x=0; x&lt;arr.length; x++) &#123; for(int y=0; y&lt;arr[x].length; y++) &#123; System.out.print(arr[x][y]+&quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 二维数组求和公司年销售额求和 某公司按照季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 1234567891011121314151617181920212223242526272829303132333435363738/* 公司年销售额求和 某公司按照季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 分析： A:把题目的数据用二维数组来表示 int[][] arr = &#123;&#123;22,66,44&#125;,&#123;77,33,88&#125;,&#123;25,45,65&#125;,&#123;11,66,99&#125;&#125;; B:如何求和呢? 求和其实就是获取到每一个元素，然后累加即可。 C:定义一个求和变量sum，初始化值是0。 D:通过遍历就可以得到每一个二维数组的元素。 E:把元素累加即可。 F:最后输出sum，就是结果。*/class Array2Test2 &#123; public static void main(String[] args) &#123; //把题目的数据用二维数组来表示 int[][] arr = &#123;&#123;22,66,44&#125;,&#123;77,33,88&#125;,&#123;25,45,65&#125;,&#123;11,66,99&#125;&#125;; //定义一个求和变量sum，初始化值是0。 int sum = 0; //通过遍历就可以得到每一个二维数组的元素。 for(int x=0; x&lt;arr.length; x++) &#123; for(int y=0; y&lt;arr[x].length; y++) &#123; //把元素累加即可。 sum += arr[x][y]; &#125; &#125; //最后输出sum，就是结果。 System.out.println(&quot;一年的销售额为：&quot;+sum+&quot;万元&quot;); &#125;&#125; 打印杨辉三角形(行数可以键盘录入)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 需求：打印杨辉三角形(行数可以键盘录入) 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 分析：看这种图像的规律 A:任何一行的第一列和最后一列都是1 B:从第三行开始，每一个数据是它上一行的前一列和它上一行的本列之和。 步骤： A:首先定义一个二维数组。行数如果是n，我们把列数也先定义为n。 这个n的数据来自于键盘录入。 B:给这个二维数组任何一行的第一列和最后一列赋值为1 C:按照规律给其他元素赋值 从第三行开始，每一个数据是它上一行的前一列和它上一行的本列之和。 D:遍历这个二维数组。*/import java.util.Scanner;class Array2Test3 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //这个n的数据来自于键盘录入。 System.out.println(&quot;请输入一个数据：&quot;); int n = sc.nextInt(); //定义二维数组 int[][] arr = new int[n][n]; //给这个二维数组任何一行的第一列和最后一列赋值为1 for(int x=0; x&lt;arr.length; x++) &#123; arr[x][0] = 1; //任何一行第1列 arr[x][x] = 1; //任何一行的最后1列 &#125; //按照规律给其他元素赋值 //从第三行开始，每一个数据是它上一行的前一列和它上一行的本列之和。 for(int x=2; x&lt;arr.length; x++) &#123; //这里如果y&lt;=x是有个小问题的，就是最后一列的问题 //所以这里要减去1 //并且y也应该从1开始，因为第一列也是有值了 for(int y=1; y&lt;=x-1; y++) &#123; //每一个数据是它上一行的前一列和它上一行的本列之和。 arr[x][y] = arr[x-1][y-1] + arr[x-1][y]; &#125; &#125; //遍历这个二维数组。 /* for(int x=0; x&lt;arr.length; x++) &#123; for(int y=0; y&lt;arr[x].length; y++) &#123; System.out.print(arr[x][y]+&quot;\\t&quot;); &#125; System.out.println(); &#125; */ //这个时候，要注意了，内循环的变化必须和曾经讲过的九九乘法表类似 for(int x=0; x&lt;arr.length; x++) &#123; for(int y=0; y&lt;=x; y++) &#123; System.out.print(arr[x][y]+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 思考题1123456789101112131415161718192021222324252627282930313233343536/* 思考题1：看程序写结果，然后分析为什么是这个样子的。并画图讲解。最后总结Java中参数传递规律。 Java中的参数传递问题： 基本类型：形式参数的改变对实际参数没有影响。 引用类型：形式参数的改变直接影响实际参数。*/class ArgsDemo &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); //a:10,b:20 change(a,b); System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); //??? a:10,b:20 int[] arr = &#123;1,2,3,4,5&#125;; change(arr); System.out.println(arr[1]); //??? 4 &#125; public static void change(int a,int b) &#123; //a=10,b=20 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); //a:10,b:20 a = b; //a=20 b = a + b; //b=40 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); //a:20,b:40 &#125; public static void change(int[] arr) &#123; //arr=&#123;1,2,3,4,5&#125;; for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x]%2==0) &#123; arr[x]*=2; &#125; &#125; //arr=&#123;1,4,3,8,5&#125;; &#125;&#125; 内存图演示 思考题21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* 某个公司采用公用电话传递数据信息，数据是小于8位的整数，为了确保安全， 在传递过程中需要加密，加密规则如下： 首先将数据倒序，然后将每位数字都加上5，再用和除以10的余数代替该数字， 最后将第一位和最后一位数字交换。 请任意给定一个小于8位的整数， 然后，把加密后的结果在控制台打印出来。 题目要求： A:数据是小于8位的整数 定义一个int类型的数据 int number = 123456; B:加密规则 a:首先将数据倒序 结果 654321 b:然后将每位数字都加上5，再用和除以10的余数代替该数字 结果 109876 c:最后将第一位和最后一位数字交换 结果 609871 C:把加密后的结果输出在控制台 通过简单的分析，我们知道如果我们有办法把这个数据变成数组就好了。 不是直接写成这个样子的： int[] arr = &#123;1,2,3,4,5,6&#125;; 如何把数据转成数组呢? A:定义一个数据 int number = 123456; B:定义一个数组,这个时候问题就来了，数组的长度是多少呢? int[] arr = new int[8]; //不可能超过8 在赋值的时候，我用一个变量记录索引的变化。 定义一个索引值是0 int index = 0; C:获取每一个数据 int ge = number%10 int shi = number/10%10 int bai = number/10/10%10 arr[index] = ge; index++; arr[index] = shi; index++; arr[index] = bai; ...*/class JiaMiDemo &#123; public static void main(String[] args) &#123; //定义一个数据 int number = 123456; //定义一个数组 int[] arr = new int[8]; //把数据中每一位上的数据获取到后存储到数组中 /* int index = 0; arr[index] = number%10; //arr[0]=6; index++; arr[index] = number/10%10; //arr[1]=5; index++; arr[index] = mumber/10/10%10; //arr[2]=4; */ //通过观察这个代码，我们发现应该是可以通过循环改进的 int index = 0; while(number &gt; 0) &#123; //number=123456,number=12345,number=1234,number=123,number=12,number=1,number=0 arr[index] = number%10; //arr[0]=6,arr[1]=5,arr[2]=4,arr[3]=3,arr[4]=2,arr[5]=1 index++;//index=1,index=2,index=3,index=4,index=5,index=6 number/=10;//number=12345,number=1234,number=123,number=12,number=1,number=0 &#125; //然后将每位数字都加上5，再用和除以10的余数代替该数字 for(int x=0; x&lt;index; x++) &#123; arr[x] += 5; arr[x] %= 10; &#125; //最后将第一位和最后一位数字交换 int temp = arr[0]; arr[0] = arr[index-1]; arr[index-1] = temp; //输出数据 for(int x=0; x&lt;index; x++) &#123; System.out.print(arr[x]); &#125; System.out.println(); &#125;&#125; 改进版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 把刚才的代码改进一下： A:把数据改进为键盘录入 B:把代码改进为方法实现 另一个数据的测试： number:1234567 第一步：7654321 第二步：2109876 第三步：6109872 知识点： 变量 数据类型 运算符 键盘录入 语句 方法 数组*/import java.util.Scanner;class JiaMiDemo2 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //请输入一个数据 System.out.println(&quot;请输入一个数据(小于8位)：&quot;); int number = sc.nextInt(); //写功能实现把number进行加密 //调用 String result = jiaMi(number); System.out.println(&quot;加密后的结果是：&quot;+result); &#125; /* 需求：写一个功能，把数据number实现加密。 两个明确： 返回值类型：String 做一个字符串的拼接。 参数列表：int number */ public static String jiaMi(int number) &#123; //定义数组 int[] arr = new int[8]; //定义索引 int index = 0; //把number中的数据想办法放到数组中 while(number &gt; 0) &#123; arr[index] = number%10; index++; number /= 10; &#125; //把每个数据加5，然后对10取得余数 for(int x=0; x&lt;index; x++) &#123; arr[x] += 5; arr[x] %= 10; &#125; //把第一位和最后一位交换 int temp = arr[0]; arr[0] = arr[index-1]; arr[index-1] = temp; //把数组的元素拼接成一个字符串返回 //定义一个空内容字符串 String s = &quot;&quot;; for(int x=0; x&lt;index; x++) &#123; s += arr[x]; &#125; return s; &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】27-二维数组定义详解","slug":"【JavaSe必知必会】27-二维数组定义详解","date":"2018-11-15T09:20:08.000Z","updated":"2018-11-19T10:25:32.316Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】27-二维数组定义详解/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】27-二维数组定义详解/","excerpt":"","text":"二维数组概述二维数组其实就是一个元素为一维数组的数组。 二维数组定义格式格式1 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组有多少个一维数组 n表示每一个一维数组的元素个数 举例： int[][] arr = new int[3][2]; 定义了一个二维数组arr 这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2] 每个一维数组有2个元素，可以通过arr[m][n]来获取 表示获取第m+1个一维数组的第n+1个元素代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041/* 二维数组：就是元素为一维数组的一个数组。 格式1： 数据类型[][] 数组名 = new 数据类型[m][n]; m:表示这个二维数组有多少个一维数组。 n:表示每一个一维数组的元素有多少个。 注意： A:以下格式也可以表示二维数组 a:数据类型 数组名[][] = new 数据类型[m][n]; b:数据类型[] 数组名[] = new 数据类型[m][n]; B:注意下面定义的区别 int x; int y; int x,y; int[] x; int[] y[]; int[] x,y[];*/class Array2Demo &#123; public static void main(String[] args) &#123; //定义一个二维数组 int[][] arr = new int[3][2]; //定义了一个二维数组arr //这个二维数组有3个一维数组的元素 //每一个一维数组有2个元素 //输出二维数组名称 System.out.println(arr); //地址值 [[I@175078b //输出二维数组的第一个元素一维数组的名称 System.out.println(arr[0]); //地址值 [I@42552c System.out.println(arr[1]); //地址值 [I@e5bbd6 System.out.println(arr[2]); //地址值 [I@8ee016 //输出二维数组的元素 System.out.println(arr[0][0]); //0 System.out.println(arr[0][1]); //0 &#125;&#125; 内存图展示 格式2数据类型[][] 变量名 = new 数据类型[m][]; m表示这个二维数组有多少个一维数组 这一次没有直接给出一维数组的元素个数，可以动态的给出。 举例： int[][] arr = new int[3][]; arr[0] = new int[2]; arr[1] = new int[3] arr[2] = new int[1];代码演示 1234567891011121314151617181920212223242526272829303132333435/* 格式2： 数据类型[][] 数组名 = new 数据类型[m][]; m:表示这个二维数组有多少个一维数组。 列数没有给出，可以动态的给。这一次是一个变化的列数。*/class Array2Demo2 &#123; public static void main(String[] args) &#123; //定义数组 int[][] arr = new int[3][]; System.out.println(arr); //[[I@175078b System.out.println(arr[0]); //null System.out.println(arr[1]); //null System.out.println(arr[2]); //null //动态的为每一个一维数组分配空间 arr[0] = new int[2]; arr[1] = new int[3]; arr[2] = new int[1]; System.out.println(arr[0]); //[I@42552c System.out.println(arr[1]); //[I@e5bbd6 System.out.println(arr[2]); //[I@8ee016 System.out.println(arr[0][0]); //0 System.out.println(arr[0][1]); //0 //ArrayIndexOutOfBoundsException //System.out.println(arr[0][2]); //错误 arr[1][0] = 100; arr[1][2] = 200; &#125;&#125; 内存图展示 格式312345数据类型[][] 变量名 = new 数据类型[][]&#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;简化版格式：数据类型[][] 变量名 = &#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;举例： int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,6&#125;,&#123;6&#125;&#125;; 代码演示12345678910111213141516171819202122232425262728293031/* 格式3： 基本格式： 数据类型[][] 数组名 = new 数据类型[][]&#123;&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;&#125;; 简化版格式： 数据类型[][] 数组名 = &#123;&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;&#125;; 举例： int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6&#125;&#125;;*/class Array2Demo3 &#123; public static void main(String[] args) &#123; //定义数组 int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6&#125;&#125;; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[0][0]); //1 System.out.println(arr[1][0]); //4 System.out.println(arr[2][0]); //6 System.out.println(arr[0][1]); //2 System.out.println(arr[1][1]); //5 //越界 System.out.println(arr[2][1]); //错误 &#125;&#125; 内存图展示","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】26-数组常见问题与操作","slug":"【JavaSe必知必会】26-数组常见问题与操作","date":"2018-11-15T09:18:47.000Z","updated":"2018-11-19T10:25:32.314Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】26-数组常见问题与操作/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】26-数组常见问题与操作/","excerpt":"","text":"数组操作常见的两个小问题 数组索引越界 ArrayIndexOutOfBoundsException 访问到了数组中的不存在的索引时发生。 空指针异常 NullPointerException 数组引用没有指向实体，却在操作实体中的元素时。 1234567891011121314151617181920212223/* 数组操作的两个常见小问题： ArrayIndexOutOfBoundsException:数组索引越界异常 原因：你访问了不存在的索引。 NullPointerException:空指针异常 原因：数组已经不在指向堆内存了。而你还用数组名去访问元素。 作用：请自己把所有的场景Exception结尾的问题总结一下。以后遇到就记录下来。 现象，原因，解决方案。*/class ArrayDemo6 &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = &#123;1,2,3&#125;; //System.out.println(arr[3]); //引用类型的常量：空常量 null arr = null; System.out.println(arr[0]); &#125;&#125; 数组练习(常见操作)数组遍历(依次输出数组中的每一个元素)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 数组遍历：就是依次输出数组中的每一个元素。 注意：数组提供了一个属性length，用于获取数组的长度。 格式：数组名.length*/class ArrayTest &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = &#123;11,22,33,44,55&#125;; //获取每一个元素 //如何获取呢?我们知道数组名结合编号(索引)就可以找到数据 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]); System.out.println(arr[4]); System.out.println(&quot;--------------------&quot;); //虽然这种做法可以，但是不是我想要的 //我们发现，代码的重复度很高 //输出语句，数组名都是相同的，仅仅是索引是变化的 //我们就可以使用循环搞定索引值 for(int x=0; x&lt;5; x++) &#123; //x=0,1,2,3,4 System.out.println(arr[x]); &#125; System.out.println(&quot;--------------------&quot;); //从0开始我们是明确的，但是为什么到5呢，我们是数了一下数组的个数 //继续看下个数组如何遍历 int[] arr2 = &#123;1,2,3,4,5,6,7,8,9,10,11,2,2,3,4,5,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8&#125;; //而我们在很多时候，数组的元素不能靠数 //这个时候，数组就给我们提供了一个属性：length专门用于获取数组的长度 //格式：数组名.length 返回数组的长度 System.out.println(arr.length); System.out.println(arr2.length); System.out.println(&quot;--------------------&quot;); //改进第一个程序 for(int x=0; x&lt;arr.length; x++) &#123; System.out.println(arr[x]); &#125; System.out.println(&quot;--------------------&quot;); //我们如果想要对多个数组进行遍历，每个数组的遍历我们都把代码写一遍，麻烦不 //麻烦，所以，我们准备用方法改进。 //用方法改进后，请调用 printArray(arr); System.out.println(&quot;--------------------&quot;); printArray(arr2); System.out.println(&quot;--------------------&quot;); printArray2(arr); &#125; /* 遍历数组的方法 两个明确： 返回值类型：void 参数列表：int[] arr */ public static void printArray(int[] arr) &#123; for(int x=0; x&lt;arr.length; x++) &#123; System.out.println(arr[x]); &#125; &#125; //请看改进版本 public static void printArray2(int[] arr) &#123; System.out.print(&quot;[&quot;); for(int x=0; x&lt;arr.length; x++) &#123; if(x == arr.length-1) &#123; //这是最后一个元素 System.out.println(arr[x]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[x]+&quot;, &quot;); &#125; &#125; &#125;&#125; 数组获取最值(获取数组中的最大值最小值)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 数组获取最值(获取数组中的最大值最小值) 分析： A:定义一个数组，并对数组的元素进行静态初始化。 B:从数组中任意的找一个元素作为参照物(一般取第一个),默认它就是最大值。 C:然后遍历其他的元素，依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 D:最后参照物里面保存的就是最大值。*/class ArrayTest2 &#123; public static void main(String[] args) &#123; //定义一个数组 int[] arr = &#123;34,98,10,25,67&#125;; //请获取数组中的最大值 /* //从数组中任意的找一个元素作为参照物 int max = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 if(arr[x] &gt; max) &#123; max = arr[x]; &#125; &#125; //最后参照物里面保存的就是最大值。 System.out.println(&quot;max:&quot;+max); */ //把这个代码用方法改进 //调用方法 int max = getMax(arr); System.out.println(&quot;max:&quot;+max); //请获取数组中的最小值 int min = getMin(arr); System.out.println(&quot;min:&quot;+min); &#125; /* 需求：获取数组中的最大值 两个明确： 返回值类型：int 参数列表：int[] arr */ public static int getMax(int[] arr) &#123; //从数组中任意的找一个元素作为参照物 int max = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 if(arr[x] &gt; max) &#123; max = arr[x]; &#125; &#125; //最后参照物里面保存的就是最大值。 return max; &#125; public static int getMin(int[] arr) &#123; //从数组中任意的找一个元素作为参照物 int min = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果小就留下来，如果大，就离开。 if(arr[x] &lt; min) &#123; min = arr[x]; &#125; &#125; //最后参照物里面保存的就是最小值。 return min; &#125;&#125; 数组元素逆序 (就是把元素对调)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* 数组元素逆序 (就是把元素对调) 分析： A:定义一个数组，并进行静态初始化。 B:思路 把0索引和arr.length-1的数据交换 把1索引和arr.length-2的数据交换 ... 只要做到arr.length/2的时候即可。*/class ArrayTest3 &#123; public static void main(String[] args) &#123; //定义一个数组，并进行静态初始化。 int[] arr = &#123;12,98,50,34,76&#125;; //逆序前 System.out.println(&quot;逆序前：&quot;); printArray(arr); //逆序后 System.out.println(&quot;逆序后：&quot;); //reverse(arr); reverse2(arr); printArray(arr); &#125; /* 需求：数组逆序 两个明确： 返回值类型：void (有人会想到应该返回的是逆序后的数组，但是没必要，因为这两个数组其实是同一个数组) 参数列表：int[] arr */ public static void reverse(int[] arr) &#123; /* //第一次交换 int temp = arr[0]; arr[0] = arr[arr.length-1-0]; arr[arr.length-1-0] = temp; //第二次交换 int temp = arr[1]; arr[1] = arr[arr.length-1-1]; arr[arr.length-1-1] = temp; //第三次交换 int temp = arr[2]; arr[2] = arr[arr.length-1-2]; arr[arr.length-1-2] = temp; */ //用循环改进 for(int x=0; x&lt;arr.length/2; x++) &#123; int temp = arr[x]; arr[x] = arr[arr.length-1-x]; arr[arr.length-1-x] = temp; &#125; &#125; public static void reverse2(int[] arr) &#123; for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) &#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125; //遍历数组 public static void printArray(int[] arr) &#123; System.out.print(&quot;[&quot;); for(int x=0; x&lt;arr.length; x++) &#123; if(x == arr.length-1) &#123; //这是最后一个元素 System.out.println(arr[x]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[x]+&quot;, &quot;); &#125; &#125; &#125;&#125; 数组元素查找(查找指定元素第一次在数组中出现的索引)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 需求：数组元素查找(查找指定元素第一次在数组中出现的索引) 分析： A:定义一个数组，并静态初始化。 B:写一个功能实现 遍历数组，依次获取数组中的每一个元素，和已知的数据进行比较 如果相等，就返回当前的索引值。*/class ArrayTest5 &#123; public static void main(String[] args) &#123; //定义一个数组，并静态初始化 int[] arr = &#123;200,250,38,888,444&#125;; //需求：我要查找250在这个数组中第一次出现的索引 int index = getIndex(arr,250); System.out.println(&quot;250在数组中第一次出现的索引是：&quot;+index); int index2 = getIndex2(arr,250); System.out.println(&quot;250在数组中第一次出现的索引是：&quot;+index2); int index3 = getIndex2(arr,2500); System.out.println(&quot;2500在数组中第一次出现的索引是：&quot;+index3); &#125; /* 需求：查找指定数据在数组中第一次出现的索引 两个明确： 返回值类型：int 参数列表：int[] arr,int value */ public static int getIndex(int[] arr,int value) &#123; //遍历数组，依次获取数组中的每一个元素，和已知的数据进行比较 for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x] == value) &#123; //如果相等，就返回当前的索引值。 return x; &#125; &#125; //目前的代码有一个小问题 //就是假如我要查找的数据在数组中不存在，那就找不到，找不到，你就对应的返回吗? //所以报错。 //只要是判断，就可能是false，所以大家要细心。 //如果找不到数据，我们一般返回一个负数即可，而且是返回-1 return -1; &#125; public static int getIndex2(int[] arr,int value) &#123; //定义一个索引 int index = -1; //有就修改索引值 for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x] == value) &#123; index = x; break; &#125; &#125; //返回index return index; &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】25-数组定义与初始化","slug":"【JavaSe必知必会】25-数组定义与初始化","date":"2018-11-15T09:17:43.000Z","updated":"2018-11-19T10:25:32.312Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】25-数组定义与初始化/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】25-数组定义与初始化/","excerpt":"","text":"数组概述 需求：现在需要统计某公司员工的工资情况，例如计算平均工资、找到最高工资等。假设该公司有80名员工，用前面所学的知识，程序首先需要声明80个变量来分别记住每位员工的工资，然后在进行操作，这样做会显得很麻烦。为了解决这种问题，Java就提供了数组供我们使用。 那么数组到底是什么呢?有什么特点呢?通过上面的分析：我们可以得到如下两句话： 数组是存储多个变量(元素)的东西(容器) 这多个变量的数据类型要一致数组概念 数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。 数组的定义格式 格式1：数据类型[] 数组名; 格式2：数据类型 数组名[]; 注意：这两种定义做完了，数组中是没有元素值的。 针对数组定义两种格式，推荐使用第一种格式。因为第一种的可读性更强。 第二种可以早期的时候确实有很多人这样用。不过，现在这样用的人越来越少了。 作为Java的粉丝C#(Java的模仿者)就不再支持第二种语法格式了。越来越多的语言可能会抛弃第二种格式。 数组的初始化数组初始化概述 Java中的数组必须先初始化,然后才能使用。 所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。数组的初始化方式 动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。动态初始化代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 数组:存储同一种数据类型的多个元素的容器。 定义格式： A:数据类型[] 数组名; B:数据类型 数组名[]; 举例： A:int[] a; 定义一个int类型的数组a变量 B:int a[]; 定义一个int类型的a数组变量 注意：效果可以认为是一样的，都是定义一个int数组，但是念法上有些小区别。推荐使用第一种。 如何对数组进行初始化呢? A:何谓初始化呢? 就是为数组开辟内存空间，并为每个数组元素赋予值 B:有几种方式呢? a:动态初始化 只指定长度，由系统给出初始化值 b:静态初始化 给出初始化值，由系统决定长度 动态初始化的格式： 数据类型[] 数组名 = new 数据类型[数组长度]; 举例： int[] arr = new int[3]; 如何获取数组中的元素呢? 通过: 数组名[索引] 索引其实就是每个元素的编号，从0开始，最大索引是数组的长度-1。*/class ArrayDemo &#123; public static void main(String[] args) &#123; //定义一个数组 //int[] a; //可能尚未初始化变量a //System.out.println(a); int[] arr = new int[3]; /* 左边： int:说明数组中的元素的数据类型是int类型 []:说明这是一个数组 arr:是数组的名称 右边： new:为数组分配内存空间。 int:说明数组中的元素的数据类型是int类型 []:说明这是一个数组 3:数组长度，其实也就是数组中元素的个数 */ System.out.println(arr); //[I@175078b 地址值。 //我要地址值没有意义啊，我就要数据值，怎么办呢? //不用担心，java为你考虑到了。 //其实数组中的每个元素都是有编号的，并且是从0开始。最大编号是数组的长度-1。 //用数组名和编号的配合就可以获取数组中的指定编号的元素。这个编号的专业叫法：索引 //通过数组名访问数据的格式是：数组名[索引]; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 一个数组的内存图演示1234567891011121314151617181920212223242526272829/* 定义一个数组，输出该数组的名称和数组元素值。 给数组元素赋值，再次输出该数组的名称和数组元素值。*/class ArrayDemo2 &#123; public static void main(String[] args) &#123; //定义一个数组 int[] arr = new int[3]; //输出数组名称 System.out.println(arr); //输出数组元素值 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(&quot;----&quot;); //给数组元素赋值 arr[0] = 100; arr[2] = 200; //输出数组名称 System.out.println(arr); //输出数组元素值 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 两个数组的内存图演示1234567891011121314151617181920212223242526272829303132333435363738394041/* 定义两个数组，分别输出两个数组各自的数组名及元素值。 然后给每个数组的元素重新赋值，再次分别输出两个数组各自的数组名及元素值。*/class ArrayDemo3 &#123; public static void main(String[] args) &#123; //定义第一个数组 int[] arr = new int[2]; //定义第二个数组 int[] arr2 = new int[3]; //输出数组名和元素值 System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(&quot;----&quot;); System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); System.out.println(&quot;----&quot;); //给元素重新赋值 arr[1] = 20; arr2[1] = 30; arr2[0] = 40; //输出数组名和元素值 System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(&quot;----&quot;); System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); &#125;&#125; 三个数组的内存图演示12345678910111213141516171819202122232425262728293031323334353637383940/* 定义第一个数组,定义完毕后，给数组元素赋值。赋值完毕后，在输出数组名称和元素。 定义第二个数组,定义完毕后，给数组元素赋值。赋值完毕后，在输出数组名称和元素。 定义第三个数组,把第一个数组的地址值赋值给它。(注意类型一致)，通过第三个数组的名称去把元素重复赋值。 最后，再次输出第一个数组数组名称和元素。*/class ArrayDemo4 &#123; public static void main(String[] args) &#123; //定义第一个数组 int[] arr = new int[3]; arr[0] = 88; arr[1] = 33; arr[2] = 66; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(&quot;----&quot;); //定义第二个数组 int[] arr2 = new int[3]; arr2[0] = 22; arr2[1] = 44; arr2[2] = 55; System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); System.out.println(&quot;----&quot;); //定义第三个数组 int[] arr3 = arr; arr3[0] = 100; arr3[1] = 200; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 数组静态初始化1234567891011121314151617181920212223242526272829/* 数组的静态初始化： 格式：数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,…&#125;; 简化格式： 数据类型[] 数组名 = &#123;元素1,元素2,…&#125;; 举例： int[] arr = new int[]&#123;1,2,3&#125;; 简化后： int[] arr = &#123;1,2,3&#125;; 注意事项： 不要同时动态和静态进行。 如下格式： int[] arr = new int[3]&#123;1,2,3&#125;; //错误*/class ArrayDemo5 &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = &#123;1,2,3&#125;; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 内存图演示","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】24-形式参数是类名的方法的调用方式","slug":"【JavaSe必知必会】24-形式参数是类名的方法的调用方式","date":"2018-11-15T09:15:30.000Z","updated":"2018-11-19T10:25:32.310Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】24-形式参数是类名的方法的调用方式/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】24-形式参数是类名的方法的调用方式/","excerpt":"","text":"形式参数是类名的方法的调用方式形式参数的问题： 基本类型：形式参数的改变不影响实际参数 引用类型：形式参数的改变直接影响实际参数12345678910111213141516171819202122232425262728293031323334353637383940/* 形式参数的问题： 基本类型：形式参数的改变不影响实际参数 引用类型：形式参数的改变直接影响实际参数*///形式参数是基本类型class Demo&#123; public int sum(int a,int b)&#123; return a + b; &#125;&#125;//形式参数是引用类型class Student&#123; public void study()&#123; System.out.println(&quot;看呆萌钟的视频有助学习&quot;); &#125;&#125;class StudentDemo&#123; public void method(Student s)&#123; s.study(); &#125;&#125;class ArgsTest &#123; public static void main(String[] args)&#123; //形式参数是基本类型的调用 Demo d = new Demo(); int result = d.sum(10,20); System.out.println(&quot;result:&quot;+result); //形式参数是引用类型的调用 //需求：我要调用StudentDemo类中的method()方法 StudentDemo sd = new StudentDemo(); //创建学生对象 Student s = new Student(); sd.method(s);//把s的地址给到了这里 &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】23-成员变量和局部变量的区别","slug":"【JavaSe必知必会】23-成员变量和局部变量的区别","date":"2018-11-15T09:14:34.000Z","updated":"2018-11-19T10:25:32.308Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】23-成员变量和局部变量的区别/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】23-成员变量和局部变量的区别/","excerpt":"","text":"成员变量与局部变量的区别 在类中的位置不同 成员变量：在类中方法外 局部变量：在方法定义中或者方法声明上 在内存中的位置不同 成员变量：在堆内存 局部变量：在栈内存 生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 初始化值不同 成员变量：有默认初始化值 局部变量：没有默认初始化值，必须定义，赋值，然后才能使用注意事项局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则代码演示1234567891011121314151617181920212223242526class Variable &#123; //成员变量 //int num = 10; int num;//0; public void show()&#123; //int num2 = 20;//局部变量 //可能尚未初始化变量num2 //int num2;//没有默认值 int num2 = 20; System.out.println(num2); //int num = 100; System.out.println(num); &#125;&#125;class VariableDemo &#123; public static void main(String[] args)&#123; Variable v = new Variable(); System.out.println(v.num);//访问成员变量 v.show(); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】22-Java对象内存分析","slug":"【JavaSe必知必会】22-Java对象内存分析","date":"2018-11-15T09:13:22.000Z","updated":"2018-11-19T10:25:32.307Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】22-Java对象内存分析/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】22-Java对象内存分析/","excerpt":"","text":"Java中的内存分配Java 程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 栈 存储局部变量 局部变量 在方法定义中或者方法声明上的变量都称为局部变量，使用完毕，立即消失 堆 存储new出来的东西 每一个实体都有首地址值 每一个实体内的数据都有默认值 byte,short,int,long 0 float,double 0.0 char ‘\\u0000’ boolean false 引用类型：null 使用完毕后，会被垃圾回收器空闲的时候回收。 方法区 被虚拟机加载的类信息、常量、静态常量等。 本地方法区 (和系统相关) 寄存器 (给CPU使用) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Phone&#123; //品牌 String brand; //价格 int price; //颜色 String color; //打电话 public void call(String name)&#123; System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); &#125; //发短信 public void sendMessage()&#123; System.out.println(&quot;发短信。。。&quot;); &#125; //玩游戏 public void playGame()&#123; System.out.println(&quot;王者荣耀carry中。。。&quot;); &#125;&#125;class PhoneDemo&#123; public static void main(String[] args)&#123; //使用前需要创建对象 //类名 对象名 = new 类名(); Phone p = new Phone(); System.out.println(p.brand+&quot;===&quot;+p.price+&quot;===&quot;+p.color); //给成员赋值 p.brand = &quot;iPhone X&quot;; p.price = 6888; p.color = &quot;黑色&quot;; System.out.println(p.brand+&quot;===&quot;+p.price+&quot;===&quot;+p.color); //调用方法 p.call(&quot;呆萌钟&quot;); p.sendMessage(); p.playGame(); System.out.println(&quot;------------------------&quot;); Phone p2 = new Phone(); System.out.println(p2.brand+&quot;===&quot;+p2.price+&quot;===&quot;+p2.color); //给成员赋值 p2.brand = &quot;锤子&quot;; p2.price = 2299; p2.color = &quot;红色&quot;; System.out.println(p2.brand+&quot;===&quot;+p2.price+&quot;===&quot;+p2.color); //调用方法 p2.call(&quot;迪丽热巴&quot;); p2.sendMessage(); p2.playGame(); System.out.println(&quot;------------------------&quot;); Phone p3 = p; System.out.println(p3.brand+&quot;===&quot;+p3.price+&quot;===&quot;+p3.color); //给成员赋值 p3.brand = &quot;华为&quot;; p3.price = 1999; p3.color = &quot;蓝色&quot;; System.out.println(p3.brand+&quot;===&quot;+p3.price+&quot;===&quot;+p3.color); System.out.println(p.brand+&quot;===&quot;+p.price+&quot;===&quot;+p.color); &#125;&#125; 一个对象的内存图 两个对象的内存图 三个对象的内存图","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】21-类与对象的定义与使用","slug":"【JavaSe必知必会】21-类与对象的定义与使用","date":"2018-11-15T09:11:50.000Z","updated":"2018-11-19T10:25:32.305Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】21-类与对象的定义与使用/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】21-类与对象的定义与使用/","excerpt":"","text":"类与对象关系 我们学习编程语言，就是为了模拟现实世界的事物，实现信息化。 比如：去超市买东西的计费系统，去银行办业务的系统。 我们如何表示一个现实世界事物呢： 属性 就是该事物的描述信息 行为 就是该事物能够做什么 举例：学生事物 我们学习的Java语言最基本单位是类，所以，我们就应该把事物用一个类来体现。 1234567类：是一组相关的属性和行为的集合对象：是该类事物的具体体现举例：类 学生对象 班长就是一个对象 类：可以理解为构造对象的一个蓝图或者模版，是抽象的概念对象：是以类为模型创建的具体实例，是对类的一种具体化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 案例：定义一个学生类 学生事物： 属性：姓名，年龄，性别 行为：学习，吃饭，睡觉 把事物要转化为对应的类： 学生类： 成员变量：姓名，年龄，性别 成员方法：学习，吃饭，睡觉 成员变量：和以前变量的定义是一样的格式，但是位置不同，在类中方法外。 成员方法：和以前的方法定义是一样的格式，但是我们今天先去掉static。 首先我们应该定义一个类，然后完成类的成员。*///这就是学生类class Student&#123; //定义成员变量 //姓名 String name; //年龄 int age; //性别 String sex; //定义成员方法 //学习的方法 public void study()&#123; System.out.println(&quot;我在看呆萌钟的Java视频学习中ing...&quot;); &#125; //吃饭的方法 public void eat()&#123; System.out.println(&quot;大口吃饭中ing...&quot;); &#125; //睡觉的方法 public void sleep()&#123; System.out.println(&quot;天色好晚，我要睡觉啦~&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132/** 手机事物： 属性：品牌，价格，颜色 行为：打电话，发短信，玩游戏 手机类： 成员变量：品牌，价格，颜色 成员方法：打电话，发短信，玩游戏*/class Phone&#123; //品牌 String brand; //价格 int price; //颜色 String color; //打电话 public void call(String name)&#123; System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); &#125; //发短信 public void sendMessage()&#123; System.out.println(&quot;发短信。。。); &#125; //玩游戏 public void playGame()&#123; System.out.println(&quot;王者荣耀carry中。。。&quot;); &#125;&#125; 对象的使用 创建对象： 类名 对象名 = new 类名(); 对象名.成员变量 对象名.成员方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 在一个java文件中写两个类：一个基本的类，一个测试类。 注意：文件名称和测试类名称一致。 如何使用呢? 创建对象使用。 如何创建对象呢? 格式：类名 对象名 = new 类名(); 如何使用成员变量呢? 对象名.变量名 如何使用成员方法呢? 对象名.方法名(...)*///这是学生类class Student &#123; //姓名 String name; //null //年龄 int age; //0 //地址 String address; //null //学习 public void study() &#123; System.out.println(&quot;学生爱学习&quot;); &#125; //吃饭 public void eat() &#123; System.out.println(&quot;学习饿了，要吃饭&quot;); &#125; //睡觉 public void sleep() &#123; System.out.println(&quot;学习累了，要睡觉&quot;); &#125;&#125;//这是学生测试类class StudentDemo &#123; public static void main(String[] args) &#123; //类名 对象名 = new 类名(); Student s = new Student(); //输出成员变量值 //System.out.println(s.name); //System.out.println(s.age); //System.out.println(s.address); //改进写法 System.out.println(s.name+&quot;---&quot;+s.age+&quot;---&quot;+s.address); //给成员变量赋值 s.name = &quot;林青霞&quot;; s.age = 27; s.address = &quot;北京&quot;; //赋值后的输出 System.out.println(s.name+&quot;---&quot;+s.age+&quot;---&quot;+s.address); //调用方法 s.study(); s.eat(); s.sleep(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 手机类的测试*/class Phone &#123; //品牌 String brand; //价格 int price; //颜色 String color; //打电话的方法 public void call(String name) &#123; System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); &#125; //发短信的方法 public void sendMessage() &#123; System.out.println(&quot;群发短信&quot;); &#125; //玩游戏的方法 public void playGame() &#123; System.out.println(&quot;玩游戏&quot;); &#125;&#125;class PhoneDemo &#123; public static void main(String[] args) &#123; //创建手机对象 //类名 对象名 = new 类名(); Phone p = new Phone(); //直接输出成员变量值 System.out.println(p.brand+&quot;---&quot;+p.price+&quot;---&quot;+p.color); //给成员变量赋值 p.brand = &quot;诺基亚&quot;; p.price = 100; p.color = &quot;灰色&quot;; //再次输出 System.out.println(p.brand+&quot;---&quot;+p.price+&quot;---&quot;+p.color); //调用方法 p.call(&quot;林青霞&quot;); p.sendMessage(); p.playGame(); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】20-面向对象简介","slug":"【JavaSe必知必会】20-面向对象简介","date":"2018-11-15T07:51:40.000Z","updated":"2018-11-19T10:25:32.303Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】20-面向对象简介/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】20-面向对象简介/","excerpt":"","text":"面向对象思想引入前面我们讲过数组，当有多个数组都需要遍历时，我们可以将遍历的代码封装到方法中，需要遍历时，就调用相应的方法即可，提高代码的复用性。在对数组遍历的基础上继续增加需求，比如获取最值，数值逆序等，同样需要将这些功能封装到相应的方法中。这样继续封装会发现方法越来越多，于是就想能不能将这些方法继续进行封装呢？通过前面的讲解我们知道类是可以存放方法的，所以，我们就考虑使用类封装来这多个方法，将来再做数组的操作时，不用去找具体的方法，先找到这个类，然后使用这个类中的方法。这就是面向对象思想的编程方式。 面向过程思想概述 我们来回想一下，这几天我们完成一个需求的步骤：首先是搞清楚我们要做什么，然后在分析怎么做，最后我们再代码体现。一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。 在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。 那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。 面向过程的代表语言：C语言 面向对象思想概述当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。接下来我们看看面向对象到底是什么? 1:面向对象思想 面向对象是基于面向过程的编程思想。 面向过程：强调的是每一个功能的步骤 面向对象：强调的是对象，然后由对象去调用功能 2:面向对象的思想特点 A:是一种更符合我们思想习惯的思想 B:可以将复杂的事情简单化 C:将我们从执行者变成了指挥者 举例： 买电脑： 面向过程：我的了解电脑--了解我自己的需求--找对应的参数信息--去中关村买电脑--讨价还价--买回电脑 面向对象：我知道我要买电脑 -- 班长去给我买 -- 班长就买回来了 洗衣服： 面向过程：把衣服脱下--找一个盆--放点洗衣粉--加点水--把衣服扔进去--搓一搓--清洗衣服--拧干--晾起来 面向对象：把衣服脱下--打开全自动洗衣机--扔进去--一键即可--晾起来 吃饭： 面向过程：去超市买菜--摘菜--洗菜--切菜--炒菜--盛起来--吃 面向对象：上饭店吃饭，你--服务员(点菜)--厨师(做菜)--服务员(端菜)--吃 家常事物，买洗衣机和去饭店太不划算了，所以，找个对象。 但是，你不跟我好好学习，你将来4000，你对象8000。 3:把大象装进冰箱 面向过程： 动作有哪些呢? A:打开冰箱门 B:装进大象 C:关闭冰箱门 代码体现； class Demo { public static void main(String[] args) { /* System.out.println(&quot;打开冰箱门&quot;); //打开冰箱门的东西，我现在仅仅是为了演示，就写了一个输出语句 //其实，它可能需要做很多操作。 //这个时候代码就比较多一些了 //假设我要多次打开冰箱门， //代码一多，每次都写一遍，麻烦不 //我们就应该用方法改进 System.out.println(&quot;装进大象&quot;); System.out.println(&quot;关闭冰箱门&quot;); */ //写了方法以后，调用就改变了 open(); in(); close(); } public static void open() { System.out.println(&quot;打开冰箱门&quot;); } public static void in() { System.out.println(&quot;装进大象&quot;); } public static void close() { System.out.println(&quot;关闭冰箱门&quot;); } } 面向对象： 我们怎么才能更符合面向对象思想呢? A:有哪些类呢? B:每个类有哪些东西呢? C:类与类直接的关系是什么呢? 把大象装进冰箱的分析? (如何分析有哪些类呢?UML。名词提取法。) A:有哪些类呢? 大象 冰箱 Demo B:每个类有哪些东西呢? 大象： 进去 冰箱： 开门 关门 Demo: main方法 C:类与类直接的关系是什么呢? Demo中使用大象和冰箱类的功能。 代码体现： class 大象 { public static void in() { System.out.println(&quot;装进大象&quot;); } } class 冰箱 { public static void open() { System.out.println(&quot;打开冰箱门&quot;); } public static void close() { System.out.println(&quot;关闭冰箱门&quot;); } } class Demo { public static void main(String[] args) { 冰箱调用开门 大象调用进去 冰箱调用关门 } } 4:开发，设计，特征 面向对象开发 就是不断的创建对象，使用对象，指挥对象做事情。 面向对象设计 其实就是在管理和维护对象之间的关系。 面向对象特征 封装(encapsulation) 继承(inheritance) 多态(polymorphism)","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】19-方法的定义与使用","slug":"【JavaSe必知必会】19-方法的定义与使用","date":"2018-11-15T07:49:43.000Z","updated":"2018-11-19T10:25:32.301Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】19-方法的定义与使用/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】19-方法的定义与使用/","excerpt":"","text":"方法的基本定义方法定义及格式 简单的说：方法就是完成特定功能的代码块在很多语言里面都有函数的定义函数在Java中被称为方法 格式： 1234修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) &#123; 函数体; return 返回值; &#125; 方法格式的解释说明方法格式解释 修饰符 比较多，后面会详细介绍。目前public static 返回值类型 用于限定返回值的数据类型 方法名 一个名称，为了方便我们调用方法 参数类型 限定调用方法时传入参数的数据类型 参数名 是一个变量，接收调用方法时传入的参数 方法体 完成功能的代码 return 结束方法以及返回方法指定类型的值 返回值 程序被return带回的结果，返回给调用者有返回值的方法调用案例演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* 方法：完成特定功能的代码块。 注意：在很多语言里面有函数的定义，而在Java中函数被称为方法。 方法格式： 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) &#123; 方法体语句; return 返回值; &#125; 详细解释： 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： 实际参数：就是实际参与运算的。 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。 要想写好一个方法，就必须明确两个东西： A:返回值类型 结果的数据类型 B:参数列表 你要传递几个参数，以及每个参数的数据类型 需求：求两个数据之和的案例 方法的执行特点： 不调用，不执行。 如何调用呢?(有明确返回值的调用) A:单独调用,一般来说没有意义，所以不推荐。 B:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。 C:赋值调用,推荐方案。 */class FunctionDemo &#123; public static void main(String[] args) &#123; int x = 10; int y = 20; //方式1：单独调用 //sum(x,y); //方式2：输出调用 //System.out.println(sum(x,y)); //System.out.println(30); //方式3：赋值调用 int result = sum(x,y); //result在这里可以进行操作 System.out.println(result); &#125; /* 需求：求两个数据之和的案例 两个明确： 返回值类型：int 参数列表：2个，都是int类型。 */ public static int sum(int a,int b) &#123; //如何实现呢? //int c = a + b; //return c; //c就是a+b,所以，我可以直接返回a+b return a + b; &#125; &#125; 练习题练习112345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 键盘录入两个数据，返回两个数中的较大值*/import java.util.Scanner;class FunctionTest &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据:&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入第二个数据:&quot;); int b = sc.nextInt(); int result = getMax(a,b); System.out.println(&quot;较大值是：&quot;+result); &#125; /* 需求：两个数中的较大值 两个明确： 返回值类型：int 参数列表：int a,int b */ public static int getMax(int a,int b) &#123; //if语句 /* if(a &gt; b) &#123; //System.out.println(a); return a; &#125;else &#123; //System.out.println(b); return b; &#125; */ //用三元改进 //int c = ((a &gt; b)? a: b); //return c; //由于c就是后面的式子 return ((a&gt;b)? a : b); &#125;&#125; 练习21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 键盘录入两个数据，比较两个数是否相等 分析： 比较两个数是否相等结果是一个boolean类型。*/import java.util.Scanner;class FunctionTest2 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据:&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入第二个数据:&quot;); int b = sc.nextInt(); boolean flag = compare(a,b); System.out.println(flag); &#125; /* 需求：比较两个数是否相等 两个明确： 返回值类型：boolean 参数列表：int a,int b */ public static boolean compare(int a,int b) &#123; //if语句的格式2实现 /* if(a == b) &#123; return true; &#125;else &#123; return false; &#125; */ //三元改进 //boolean flag = ((a==b)? true: false); //return flag; //继续改进 //return ((a==b)? true: false); //最终版 return a == b; &#125;&#125; 练习31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 键盘录入三个数据，返回三个数中的最大值*/import java.util.Scanner;class FunctionTest3 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据:&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入第二个数据:&quot;); int b = sc.nextInt(); System.out.println(&quot;请输入第三个数据:&quot;); int c = sc.nextInt(); int max = getMax(a,b,c); System.out.println(&quot;三个数据中的最大值是：&quot;+max); &#125; /* 需求；返回三个数中的最大值 两个明确： 返回值类型：int 参数列表：int a,int b,int c */ public static int getMax(int a,int b,int c) &#123; //if嵌套 /* if(a &gt; b) &#123; if(a &gt; c) &#123; return a; &#125;else &#123; return c; &#125; &#125;else &#123; if(b &gt; c) &#123; return b; &#125;else &#123; return c; &#125; &#125; */ //用三元改 /* if(a &gt; b) &#123; return (a&gt;c? a: c); &#125;else &#123; return (b&gt;c? b: c); &#125; */ //继续改进 //return (a&gt;b)? (a&gt;c? a: c): (b&gt;c? b: c); //不建议，写代码一定要注意阅读性强 int temp = ((a&gt;b)? a: b); int max = ((temp&gt;c)? temp: c); return max; &#125;&#125; 注意事项1234567891011121314151617181920212223242526272829/* 方法的注意事项： A:方法不调用不执行 B:方法与方法是平级关系，不能嵌套定义 C:方法定义的时候参数之间用逗号隔开 D:方法调用的时候不用在传递数据类型 E:如果方法有明确的返回值，一定要有return带回一个值*/class FunctionDemo2 &#123; public static void main(String[] args) &#123; /* 错误的 public static int sum(int a,int b)&#123; return a + b; &#125; */ //sum(10,20); //int x = 10; //int y = 20; //错误 //sum(int x,int y); &#125; public static int sum(int a,int b)&#123; return a + b; &#125;&#125; void类型的方法调用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 需求：在控制台输出如下的形状 ***** ***** ***** ***** void类型返回值的方法调用： 单独调用 输出调用(错误) 赋值调用(错误)*/class FunctionDemo3 &#123; public static void main(String[] args) &#123; //for循环嵌套输出图形 for(int x=0; x&lt;4; x++) &#123; for(int y=0; y&lt;5; y++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; System.out.println(&quot;--------------&quot;); //需求：我要在控制台输出一个6行7列的星形图形 for(int x=0; x&lt;6; x++) &#123; for(int y=0; y&lt;7; y++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; System.out.println(&quot;--------------&quot;); //如果需要继续改变，我们就应该考虑使用方法改进。 //单独调用 pringXing(3,4); System.out.println(&quot;--------------&quot;); pringXing(6,7); System.out.println(&quot;--------------&quot;); pringXing(8,9); //输出调用 //此处不允许使用 &apos;空&apos; 类型 //System.out.println(pringXing(3,4)); //赋值调用 //非法的表达式开始 //void v = pringXing(3,4); &#125; /* 写一个什么样子的方法呢?写一个m行n列的代码 两个明确： 返回值类型：这个时候没有明确的返回值，不写东西还不行，所以，这里记住是void 参数列表：int m,int n */ public static void pringXing(int m,int n) &#123; for(int x=0; x&lt;m; x++) &#123; for(int y=0; y&lt;n; y++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 练习1234567891011121314151617181920212223242526272829303132/* 键盘录入一个数据n(1&lt;=n&lt;=9)，输出对应的nn乘法表*/import java.util.Scanner;public class FunctionTest3&#123; public static void main(String[] args)&#123; //创建对象 Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入n的值（1~9）:&quot;); int n = sc.nextInt(); while(n&lt;1||n&gt;9)&#123; System.out.print(&quot;您输入的数据不再有效范围内，请重新输入：&quot;); n = sc.nextInt(); &#125; //调用 printNN(n); &#125; /* 两个明确： 返回值类型：void 参数列表：int n */ public static void printNN(int n)&#123; for(int x=1;x&lt;=n;x++)&#123; for(int y=1;y&lt;=x;y++)&#123; System.out.print(y+&quot;*&quot;+x+&quot;=&quot;+y*x+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; 方法重载方法重载概述在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 方法重载特点与返回值类型无关，只看方法名和参数列表在调用时，虚拟机通过参数列表的不同来区分同名方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 需求：我要求数的和 我们的需求不断的发生改变，我们就对应的提供了多个求和的方法。 但是呢，他们的名字是不一样的。 而我们又要求方法命名做到：见名知意。 但是，很明显，现在没有做到。 那么，肿么办呢? 针对这种情况：方法的功能相同，参数列表不同的情况，为了见名知意，Java允许它们起一样的名字。 其实，这种情况有一个专业名词：方法重载。 方法重载： 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 参数列表不同： A:参数个数不同 B:参数类型不同*/class FunctionDemo4 &#123; public static void main(String[] args) &#123; //jvm会根据不同的参数去调用不同的功能 System.out.println(sum(10,20)); System.out.println(sum(10,20,30)); System.out.println(sum(10,20,30,40)); System.out.println(sum(10.5f,20f)); &#125; //需求1:求两个数的和 public static int sum(int a,int b) &#123; System.out.println(&quot;int&quot;); return a + b; &#125; //需求2:求三数的和 /* public static int sum1(int a,int b,int c) &#123; return a + b + c; &#125; */ public static int sum(int a,int b,int c) &#123; return a + b + c; &#125; //需求3:求四个数的和 /* public static int sum2(int a,int b,int c,int d) &#123; return a + b + c + d; &#125; */ public static int sum(int a,int b,int c,int d) &#123; return a + b + c + d; &#125; public static float sum(float a,float b) &#123; System.out.println(&quot;float&quot;); return a + b; &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】18-流程控制语句之跳转控制语句","slug":"【JavaSe必知必会】18-流程控制语句之跳转控制语句","date":"2018-11-15T07:48:44.000Z","updated":"2018-11-19T10:25:32.299Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】18-流程控制语句之跳转控制语句/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】18-流程控制语句之跳转控制语句/","excerpt":"","text":"跳转控制语句前面我们已经说过了，Java中的goto是保留字，目前不能使用。虽然没有goto语句可以增强程序的安全性，但是也带来很多不便，比如说，我想在某个循环知道到某一步的时候就结束，现在就做不了这件事情。为了弥补这个缺陷，Java就提供了break，continue和return来实现控制语句的跳转和中断。 break 中断break的使用场景 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的break的作用 跳出单层循环 跳出多层循环 带标签的跳出 格式：标签名: 循环语句 标签名要符合Java的命名规则案例演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 跳转控制语句： 1、break 中断 2、continue 继续 3、return 返回 break：中断 使用场景： A：switch语句中 B：循环语句中 （循环语句中加入if判断的情况） 注意：离开上面两种场景，无意义 如何使用？ A：跳出单层循环 B：跳出多层循环 要想实现多层循环，就必须知道一个东西。 带标签的语句： 格式： 标签名:语句*/public class BreakDemo&#123; public static void main(String[] args)&#123; //在 switch 或 loop 外部中断 //break; //跳出单层循 for(int i = 0;i&lt;10;i++)&#123; if(i==2)&#123; break; &#125; System.out.println(&quot;我的淘宝男装店铺名叫DM潮人社区&quot;); &#125; System.out.println(&quot;广告时间结束&quot;); System.out.println(&quot;============================&quot;); wc:for(int i = 0;i&lt;5;i++)&#123; nc:for(int j=0;j&lt;4;j++)&#123; if(j==2)&#123; break nc; &#125; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; continue 继续continue的使用场景 在循环语句中 离开使用场景的存在是没有意义的continue的作用 break 退出当前循环 continue 退出本次循环 也可以带标签的使用案例演示 1234567891011121314151617181920212223242526272829303132333435/* continue:继续 continue的使用场景： 循环中，离开此场景没用意义。 测试，对比break与continue的区别： break:跳出单层循环 continue：跳出单层循环，进入下一次的执行*/public class ContinueDemo&#123; public static void main(String[] args)&#123; for(int x=0;x&lt;10;x++)&#123; if(x==3)&#123; //break; continue; &#125; System.out.println(x); &#125; System.out.println(&quot;-------------------------&quot;); for(int i =1;i&lt;=10;i++)&#123; if(i%3==0)&#123; //在此处填写代码 //在控制台输出2次 //break; //在控制台输出7次 //continue; //在控制台输出13次 System.out.println(&quot;DM潮人社区是呆萌钟的淘宝男装店，希望大家多多支持&quot;); &#125; System.out.println(&quot;DM潮人社区是呆萌钟的淘宝男装店，希望大家多多支持&quot;); &#125; &#125;&#125; return 返回return关键字不是为了跳转出循环体，更常用的功能是结束一个方法，也就是退出一个方法。跳转到上层调用的方法。这个在方法的使用那里会在详细的讲解。 案例演示123456789101112131415161718192021/* return:返回 其实它的作用不是结束循环的，而是结束方法的。*/class ReturnDemo &#123; public static void main(String[] args) &#123; for(int x=0; x&lt;10; x++) &#123; if(x == 2) &#123; System.out.println(&quot;退出&quot;); //break; //continue; return; &#125; System.out.println(x); &#125; System.out.println(&quot;over&quot;); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】17-流程控制语句之循环结构","slug":"【JavaSe必知必会】17-流程控制语句之循环结构","date":"2018-11-15T07:47:42.000Z","updated":"2018-11-19T10:25:32.297Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】17-流程控制语句之循环结构/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】17-流程控制语句之循环结构/","excerpt":"","text":"概述 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。 循环语句的组成 初始化语句： 一条或者多条语句，这些语句完成一些初始化操作。 判断条件语句： 这是一个boolean 表达式，这个表达式能决定是否执行循环体。 循环体语句： 这个部分是循环体语句，也就是我们要多次做的事情。 控制条件语句： 这个部分在一次循环体结束后，下一次循环判断条件执行前执行。通过用于控制循环条件中的变量，使得循环在合适的时候结束。for循环语句for循环语句格式 123for(初始化语句;判断条件语句;控制条件语句) &#123; 循环体语句; &#125; 执行流程 A:执行初始化语句 B:执行判断条件语句，看其结果是true还是false 如果是false，循环结束。 如果是true，继续执行。 C:执行循环体语句 D:执行控制条件语句 E:回到B继续 代码演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 循环语句：for循环,while循环,do...while循环。 for循环格式： for(初始化语句;判断条件语句;控制条件语句) &#123; 循环体语句; &#125; 执行流程： A:执行初始化语句 B:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 C:执行循环体语句; D:执行控制条件语句 E:回到B继续。 注意事项： A:判断条件语句无论简单还是复杂结果是boolean类型。 B:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 C:一般来说：有左大括号就没有分号，有分号就没有左大括号 需求：请在控制台输出10次&quot;HelloWorld&quot;*/class ForDemo &#123; public static void main(String[] args) &#123; //最原始的做法 System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;HelloWorld&quot;); System.out.println(&quot;----------&quot;); //这种做法不好,代码的重复度太高。 //所以呢，我们用循环改进 for(int x=1;x&lt;=10;x++) &#123; System.out.println(&quot;HelloWorld&quot;); &#125; &#125;&#125; 注意事项 判断条件语句的结果是一个boolean类型 循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 一般来说：有左大括号就没有分号，有分号就没有左大括号练习第一题请在控制台输出数据1-10 1234567891011121314151617181920212223242526272829303132/* 需求：请在控制台输出数据1-10*/class ForDemo2 &#123; public static void main(String[] args) &#123; //原始做法 System.out.println(1); System.out.println(2); System.out.println(3); System.out.println(4); System.out.println(5); System.out.println(6); System.out.println(7); System.out.println(8); System.out.println(9); System.out.println(10); System.out.println(&quot;-------------&quot;); //如何改进呢?用循环改进 for(int x=1; x&lt;=10; x++) &#123; System.out.println(x); &#125; System.out.println(&quot;-------------&quot;); //从0开始 for(int x=0; x&lt;10; x++) &#123; System.out.println(x+1); &#125; &#125;&#125; 第二题求出1-10之间数据之和1234567891011121314151617181920212223242526272829303132333435363738394041/* 需求：求出1-10之间数据之和 分析： 0+1=1 1+2=3 3+3=6 6+4=10 10+5=15 ... 由此可见我们要定义两个变量： 一个变量用于存储第一个加数，第一个加数其实保存的是以前的所有数据和。默认初始化值应该是0。 一个变量用于存储第二个加数，第二个加数其实就是每次的数据变化的值。 求和思想。 */class ForDemo3 &#123; public static void main(String[] args) &#123; //原始做法 System.out.println(1+2+3+4+5+6+7+8+9+10); //定义第一个加数 int sum = 0; for(int x=1; x&lt;=10; x++) &#123; //这里的x其实是第二个加数 sum = sum + x; /* 0 + 1 = 1 1 + 2 = 3 3 + 3 = 6 ... */ //sum += x; &#125; System.out.println(&quot;sum:&quot;+sum); &#125;&#125; 第三题A:求1-100之和。B:求出1-100之间偶数和C:求出1-100之间奇数和(自己做)123456789101112131415161718192021222324252627282930313233343536373839404142/* 需求： A:求1-100之和。 B:求出1-100之间偶数和 C:求出1-100之间奇数和(自己做)*/class ForDemo4 &#123; public static void main(String[] args) &#123; //求1-100之和。 int sum1 = 0; for(int x=1; x&lt;=100; x++) &#123; sum1 +=x; &#125; System.out.println(&quot;1-100之和是：&quot;+sum1); System.out.println(&quot;------------------&quot;); //求出1-100之间偶数和 //方式1 int sum2 = 0; for(int x=1; x&lt;=100; x++) &#123; if(x%2 == 0) &#123; sum2 += x; &#125; &#125; System.out.println(&quot;1-100偶数之和是：&quot;+sum2); System.out.println(&quot;------------------&quot;); //方式2 int sum3 = 0; for(int x=0; x&lt;=100; x+=2) &#123; sum3 += x; &#125; System.out.println(&quot;1-100偶数之和是：&quot;+sum3); System.out.println(&quot;------------------&quot;); &#125;&#125; 第四题在控制台输出所有的”水仙花数”123456789101112131415161718192021222324252627282930313233343536373839404142/* 需求：在控制台输出所有的”水仙花数” 分析： 我们都不知道什么叫&quot;水仙花数&quot;，你让我怎么做呢? 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 1*1*1 + 5*5*5 + 3*3*3 = 1 + 125 + 27 = 153 A:三位数其实是告诉了我们范围。 B:通过for循环我们就可以实现获取每一个三位数 但是麻烦是如何获取这个三位数的个,十,百位上的数据 我们如何获取一个数据的个,十,百呢? 假设有个一个数据:153 ge: 153%10 = 3 shi: 153/10%10 = 5 bai：153/10/10%10 = 1 qian：x/10/10/10%10 wan: x/10/10/10/10%10 ... C:让ge*ge*ge+shi*shi*shi+bai*bai*bai和该数据比较 如果相同，就把该数据在控制台输出。*/class ForDemo6 &#123; public static void main(String[] args) &#123; //三位数其实是告诉了我们范围。 for(int x=100; x&lt;1000; x++) &#123; int ge = x%10; int shi = x/10%10; int bai = x/10/10%10; //让ge*ge*ge+shi*shi*shi+bai*bai*bai和该数据比较 if(x == (ge*ge*ge+shi*shi*shi+bai*bai*bai)) &#123; //如果相同，就把该数据在控制台输出。 System.out.println(x); &#125; &#125; &#125;&#125; while循环语句while循环语句格式12345678910基本格式 while(判断条件语句) &#123; 循环体语句; &#125;扩展格式 初始化语句; while(判断条件语句) &#123; 循环体语句; 控制条件语句; &#125; 流程图 代码演示12345678910111213141516171819202122232425262728293031/* while循环语句格式: 基本格式 while(判断条件语句) &#123; 循环体语句; &#125; 扩展格式 初始化语句; while(判断条件语句) &#123; 循环体语句; 控制条件语句; &#125; 通过这个格式，我们就可以看到其实和for循环是差不多的 for(初始化语句;判断条件语句;控制条件语句)&#123; 循环体语句; &#125;*/public class WhileDemo&#123; public static void main(String[] args)&#123; //输出10次我的淘宝店铺名：DM潮人社区 for(int x=0;x&lt;10;x++)&#123; System.out.println(&quot;我的淘宝店铺名：DM潮人社区&quot;); &#125; System.out.println(&quot;===========================&quot;); int x=0; while(x&lt;10)&#123; System.out.println(&quot;我的淘宝店铺名：DM潮人社区&quot;); x++; &#125; &#125;&#125; for循环和while循环的区别for循环语句和while循环语句可以等价转换，但还是有些小区别的 使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。 场景区别：for循环适合针对一个范围判断进行操作while循环适合判断次数不明确操作 123456789101112131415161718192021222324252627/* while循环和for循环的区别? 使用区别：如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用for循环。 因为变量及早的从内存中消失，可以提高内存的使用效率。 其实还有一种场景的理解: 如果是一个范围的，用for循环非常明确。 如果是不明确要做多少次，用while循环较为合适。 举例：吃葡萄。*/class WhileDemo4 &#123; public static void main(String[] args) &#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(&quot;祝大家端午节快乐，代码越敲越溜！&quot;); &#125; //这里不能再继续访问了 //System.out.println(i); System.out.println(&quot;=============================&quot;); Scanner sc = new Scanner(System.in); int j = sc.nextInt(); while(j&lt;10)&#123; System.out.println(&quot;祝大家端午节快乐，代码越敲越溜！&quot;); j++; &#125; System.out.println(j); &#125;&#125; 练习123456789101112131415161718192021222324252627282930313233343536373839/* 我国最高山峰是珠穆朗玛峰：8848m，我现在有一张足够大的纸张，厚度为：0.01m。 请问，我折叠多少次，就可以保证厚度不低于珠穆朗玛峰的高度? 分析： A:定义一个统计变量，默认值是0 B:最高山峰是珠穆朗玛峰：8848m这是最终的厚度 我现在有一张足够大的纸张，厚度为：0.01m这是初始厚度 C:我折叠多少次，就可以保证厚度不低于珠穆朗玛峰的高度? 折叠一次有什么变化呢?就是厚度是以前的2倍。 D:只要每次变化的厚度没有超过珠穆朗玛峰的高度，就折叠，统计变量++ E:输出统计变量。*/class WhileDemo5 &#123; public static void main(String[] args) &#123; //定义一个统计变量，默认值是0 int count = 0; //最高山峰是珠穆朗玛峰：8848m这是最终的厚度 //我现在有一张足够大的纸张，厚度为：0.01m这是初始厚度 //为了简单，我把0.01变成1，同理8848就变成了884800 int end = 884800; int start = 1; while(start&lt;end) &#123; //只要每次变化的厚度没有超过珠穆朗玛峰的高度，就折叠，统计变量++ count++; //折叠一次有什么变化呢?就是厚度是以前的2倍。 start *= 2; System.out.println(&quot;第&quot;+count+&quot;次厚度是&quot;+start); &#125; //输出统计变量。 System.out.println(&quot;要叠&quot;+count+&quot;次&quot;); &#125;&#125; do…while循环语句do…while循环语句格式12345678910基本格式 do &#123; 循环体语句; &#125;while((判断条件语句);扩展格式 初始化语句; do &#123; 循环体语句; 控制条件语句; &#125; while((判断条件语句); 流程图 1234567891011121314151617181920212223242526272829303132333435/* do...while循环的基本格式： do &#123; 循环体语句; &#125;while(判断条件语句); 扩展格式； 初始化语句; do &#123; 循环体语句; 控制条件语句; &#125;while(判断条件语句);*/class DoWhileDemo &#123; public static void main(String[] args) &#123; //输出10次HelloWorld。 int x = 0; do &#123; System.out.println(&quot;HelloWorld&quot;); x++; &#125;while(x&lt;10); System.out.println(&quot;--------------&quot;); //求和1-100 int sum = 0; int a = 1; do &#123; sum += a; a++; &#125;while(a&lt;=100); System.out.println(sum); &#125;&#125; 区别及注意事项三种循环语句其实都可以完成一样的功能，也就是说可以等价转换，但还是有小区别的: do…while循环至少会执行一次循环体。 for循环和while循环只有在条件成立的时候才会去执行循环体代码演示 12345678910111213141516171819202122232425/* 循环语句的区别: do...while循环至少执行一次循环体。 而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。 那么，我们一般使用哪种循环呢? 优先考虑for，其次考虑while，最后考虑do...while*/class DoWhileDemo2 &#123; public static void main(String[] args) &#123; int x = 3; while(x &lt; 3) &#123; System.out.println(&quot;DM潮人社区的衣服超酷的哟~&quot;); x++; &#125; System.out.println(&quot;--------------&quot;); int y = 3; do &#123; System.out.println(&quot;DM潮人社区的衣服超酷的哟~&quot;); y++; &#125;while(y &lt; 3); &#125;&#125; 注意事项： 写程序优先考虑for循环，再考虑while循环，最后考虑do…while循环。 如下代码是死循环 12while(true)&#123;&#125; for(;;)&#123;&#125; 代码演示123456789101112131415161718192021222324252627282930/* 注意死循环： A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。 B:两种最简单的死循环格式 while(true)&#123;...&#125; for(;;)&#123;...&#125; */class DoWhileDemo3 &#123; public static void main(String[] args) &#123; int x = 0; while(x &lt; 10) &#123; System.out.println(x); x++; &#125; System.out.println(&quot;--------------&quot;); /* while(true) &#123; System.out.println(&quot;今天我很高兴，学会了把循环弄死&quot;); &#125; */ for(;;)&#123; System.out.println(&quot;今天我很高兴，学会了把循环弄死&quot;); &#125; //System.out.println(&quot;--------------&quot;); &#125;&#125; 经典练习第一题12345678910111213141516171819202122232425262728293031323334353637/* 在控制台输出一个四行五列的*图案 ***** ***** ***** ***** 总结：内层循环控制列数，外层循环控制行数*/import java.util.Scanner;public class ForForTest&#123; public static void main(String[] args)&#123; //最傻最傻的办法，不合适 System.out.println(&quot;*****&quot;); System.out.println(&quot;*****&quot;); System.out.println(&quot;*****&quot;); System.out.println(&quot;*****&quot;); System.out.println(&quot;------------------------&quot;); //单for循环，不合适 for(int i = 0;i&lt;4;i++)&#123; System.out.println(&quot;*****&quot;); &#125; System.out.println(&quot;------------------------&quot;); Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要输出的列数：&quot;); int n = sc.nextInt(); System.out.println(&quot;请输入要输出的行数：&quot;); int m = sc.nextInt(); //控制行数 for(int j = 0;j&lt;m;j++)&#123; //控制每行的列数 for(int i=0;i&lt;n;i++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 第二题123456789101112131415161718192021222324252627282930313233/* 用*符号输出一个正三角形 * ** *** **** ******/public class ForForTest2&#123; public static void main(String[] args)&#123; //5行5列 for(int i = 0;i&lt;5;i++)&#123; for(int j = 0;j&lt;5;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; /* 第1行1个 第2行2个 第3行3个 第4行4个 第5行5个 */ for(int i = 0;i&lt;5;i++)&#123; for(int j=0;j&lt;=i;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 第三题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 需求：在控制台输出九九乘法表。 首先我们写出九九乘法表： 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 ... 1*9=9 2*9=18 3*9=27 ... 我们先把这个九九乘法表看出是这样的一个形状： * ** *** **** ***** ****** ******* ******** ********* 注意： &apos;\\x&apos; x表示任意，这种做法叫转移字符。 &apos;\\t&apos; tab键的位置 &apos;\\r&apos; 回车 &apos;\\n&apos; 换行*/class ForForDemo3 &#123; public static void main(String[] args) &#123; for(int x=0; x&lt;9; x++) &#123; for(int y=0; y&lt;=x; y++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; System.out.println(&quot;--------------&quot;); //为了使用数据，我们从1开始 for(int x=1; x&lt;=9; x++) &#123; for(int y=1; y&lt;=x; y++) &#123; System.out.print(y+&quot;*&quot;+x+&quot;=&quot;+y*x+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】16-流程控制语句之选择结构","slug":"【JavaSe必知必会】16-流程控制语句之选择结构","date":"2018-11-15T07:45:53.000Z","updated":"2018-11-19T10:25:32.295Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】16-流程控制语句之选择结构/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】16-流程控制语句之选择结构/","excerpt":"","text":"概述 在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。 流程控制语句分类 顺序结构 选择结构 循环结构顺序结构顺序结构概述 是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。 总的来说：写在前面的先执行，写在后面的后执行顺序结构图 1234567891011121314151617181920/* 流程控制语句：可以控制程序的执行流程。 分类： 顺序结构 选择结构 循环结构 顺序结构： 从上往下，依次执行。*/class ShunXuJieGouDemo &#123; public static void main(String[] args) &#123; System.out.println(&quot;程序开始了&quot;); System.out.println(&quot;我爱Java&quot;); System.out.println(&quot;程序结束了&quot;); &#125;&#125; 选择结构 也被称为分支结构。 选择结构有特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑运算的结果有两个，所以产生选择，按照不同的选择执行不同的代码。 Java语言提供了两种选择结构语句 if语句 switch语句选择结构(if语句)if语句有三种格式if语句第一种格式： 123if(关系表达式) &#123; 语句体 &#125; 执行流程 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体 如果是false就不执行语句体 1234567891011121314151617181920212223242526272829303132333435/* 选择结构： if语句 switch语句 if语句： 格式1 格式2 格式3 if语句的格式： if(比较表达式) &#123; 语句体; &#125; 执行流程： 先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体； 如果是false，就不执行语句体；*/class IfDemo &#123; public static void main(String[] args) &#123; int x = 10; if(x == 10) &#123; System.out.println(&quot;x等于10&quot;); &#125; if(x == 20) &#123; System.out.println(&quot;x等于20&quot;); &#125; System.out.println(&quot;over&quot;); &#125;&#125; 注意事项 关系表达式无论简单还是复杂，结果必须是boolean类型 if语句控制的语句体如果是一条语句，大括号可以省略；如果是多条语句，就不能省略。建议永远不要省略。 一般来说：有左大括号就没有分号，有分号就没有左大括号 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* if语句的注意事项： A:比较表达式无论简单还是复杂，结果必须是boolean类型 B:if语句控制的语句体如果是一条语句，大括号可以省略； 如果是多条语句，就不能省略。建议永远不要省略。 C:一般来说：有左大括号就没有分号，有分号就没有左大括号*/class IfDemo2 &#123; public static void main(String[] args) &#123; int x = 10; if(x == 10) &#123; System.out.println(&quot;x等于10&quot;); &#125; if((x &gt; 5) || (x == 10)) &#123; System.out.println(&quot;x大于或者等于10&quot;); &#125; System.out.println(&quot;-------------------&quot;); int a = 100; /* if(a == 100) &#123; System.out.println(&quot;a的值是100&quot;); &#125; */ if(a != 100) &#123; System.out.println(&quot;a的值是100&quot;); System.out.println(&quot;over&quot;); &#125; System.out.println(&quot;-------------------&quot;); int b = 100; if(b != 100); //这里其实是有语句体的，只不过是空语句体。 //代码块 &#123; System.out.println(&quot;b的值是100&quot;); System.out.println(&quot;over&quot;); &#125; &#125;&#125; if语句第二种格式12345if(关系表达式) &#123; 语句体1; &#125;else &#123; 语句体2; &#125; 执行流程 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体1 如果是false就执行语句体2 12345678910111213141516171819202122232425262728/* if语句格式2： if(比较表达式) &#123; 语句体1; &#125;else &#123; 语句体2; &#125; 执行流程： 首先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体1； 如果是false，就执行语句体2； 注意：else后面是没有比较表达式的，只有if后面有。*/class IfDemo3 &#123; public static void main(String[] args) &#123; //判断两个数据是否相等 int a = 10; int b = 20; if(a == b) &#123; System.out.println(&quot;a等于b&quot;); &#125;else &#123; System.out.println(&quot;a不等于b&quot;); &#125; &#125;&#125; 练习123456789101112131415161718192021222324252627282930313233343536373839404142/* if语句格式2的练习： A:获取两个数据中较大的值 B:判断一个数据是奇数还是偶数,并输出是奇数还是偶数*/import java.util.Scanner;class IfTest &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //获取两个数据中较大的值 System.out.println(&quot;请输入第一个数据：&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int b = sc.nextInt(); //定义一个变量接收最大值 int max; if(a &gt; b) &#123; max = a; &#125;else &#123; max = b; &#125; System.out.println(&quot;max:&quot;+max); System.out.println(&quot;----------------&quot;); //判断一个数据是奇数还是偶数 System.out.println(&quot;请输入你要判断的数据：&quot;); int x = sc.nextInt(); if(x%2 == 0) &#123; System.out.println(x+&quot;这个数据是偶数&quot;); &#125;else &#123; System.out.println(x+&quot;这个数据是奇数&quot;); &#125; &#125;&#125; 我们前面讲解过三元运算符，它根据比较判断后，给出的也是两个结果，所以，这种情况和if语句的第二种格式很相似，他们在某些情况下应该是可以相互转换的。 if语句第二种格式和三元运算符 三元运算符的操作都可以使用if语句改进，反之不成立 什么时候不成立呢? 当if语句控制的语句体是一条输出语句的时候，就不成立。因为三元运算符是一个运算符，必须要求有一个结果返回而输出语句却不能作为一个返回结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 由于if语句的第二种格式刚才也完成了三元运算符可以完成的效果。 所以，我们就认为他们可以完成一样的操作。 但是，他们就一点区别没有吗?肯定不是。 区别： 三元运算符实现的，都可以采用if语句实现。反之不成立。 什么时候if语句实现不能用三元改进呢? 当if语句控制的操作是一个输出语句的时候就不能。 为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。*/class IfDemo4 &#123; public static void main(String[] args) &#123; //获取两个数据的最大值 int a = 10; int b = 20; //用if语句实现 int max1; if(a &gt; b) &#123; max1 = a; &#125;else &#123; max1 = b; &#125; System.out.println(&quot;max1:&quot;+max1); //用三元改进 int max2 = (a &gt; b)? a: b; System.out.println(&quot;max2:&quot;+max2); System.out.println(&quot;----------&quot;); //判断一个数据是奇数还是偶数,并输出是奇数还是偶数 int x = 100; if(x%2 == 0) &#123; System.out.println(&quot;100是一个偶数&quot;); &#125;else &#123; System.out.println(&quot;100是一个奇数&quot;); &#125; //用三元改进 //这种改进是错误的。 //String s = (x%2 == 0)?System.out.println(&quot;100是一个偶数&quot;);:System.out.println(&quot;100是一个奇数&quot;);; &#125;&#125; if语句第三种格式123456789if(关系表达式1) &#123; 语句体1; &#125;else if (关系表达式2) &#123; 语句体2; &#125; … else &#123; 语句体n+1; &#125; 执行流程 首先判断关系表达式1看其结果是true还是false 如果是true就执行语句体1 如果是false就继续判断关系表达式2看其结果是true还是false 如果是true就执行语句体2 如果是false就继续判断关系表达式…看其结果是true还是false … 如果没有任何关系表达式为true，就执行语句体n+1。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* if语句的格式3： if(比较表达式1) &#123; 语句体1; &#125;else if(比较表达式2) &#123; 语句体2; &#125;else if(比较表达式3) &#123; 语句体3; &#125; ... else &#123; 语句体n+1; &#125; 执行流程： 首先计算比较表达式1看其返回值是true还是false， 如果是true，就执行语句体1，if语句结束。 如果是false，接着计算比较表达式2看其返回值是true还是false， 如果是true，就执行语句体2，if语句结束。 如果是false，接着计算比较表达式3看其返回值是true还是false， ... 如果都是false，就执行语句体n+1。*/import java.util.Scanner;class IfDemo5 &#123; public static void main(String[] args) &#123; //需求：键盘录入一个成绩，判断并输出成绩的等级。 /* 90-100 优秀 80-90 好 70-80 良 60-70 及格 0-60 不及格 */ //创建键盘录入对象 Scanner sc = new Scanner(System.in); //录入数据 System.out.println(&quot;请输入你的考试成绩：&quot;); int score = sc.nextInt(); /* if(score&gt;=90 &amp;&amp; score&lt;=100) &#123; System.out.println(&quot;优秀&quot;); &#125;else if(score&gt;=80 &amp;&amp; score&lt;90) &#123; System.out.println(&quot;好&quot;); &#125;else if(score&gt;=70 &amp;&amp; score&lt;80) &#123; System.out.println(&quot;良&quot;); &#125;else if(score&gt;=60 &amp;&amp; score&lt;70) &#123; System.out.println(&quot;及格&quot;); &#125;else &#123; System.out.println(&quot;不及格&quot;); &#125; */ //这样写已经满足我的基本要求，但是可能别人在使用的时候，不会按照你要求的数据给出了。 //在做一个程序的基本测试的时候，一定要考虑这样的几个问题： //正确数据，错误数据，边界数据。 //而我们刚才写的程序并没有处理错误数据，所以这个程序不是很好，要改进 /* if(score&gt;=90 &amp;&amp; score&lt;=100) &#123; System.out.println(&quot;优秀&quot;); &#125;else if(score&gt;=80 &amp;&amp; score&lt;90) &#123; System.out.println(&quot;好&quot;); &#125;else if(score&gt;=70 &amp;&amp; score&lt;80) &#123; System.out.println(&quot;良&quot;); &#125;else if(score&gt;=60 &amp;&amp; score&lt;70) &#123; System.out.println(&quot;及格&quot;); &#125;else if(score&gt;=0 &amp;&amp; score&lt;60)&#123; System.out.println(&quot;不及格&quot;); &#125;else &#123; System.out.println(&quot;你输入的成绩有误&quot;); &#125; */ //另一种判断改进 if(score&lt;0 || score&gt;100) &#123; System.out.println(&quot;你输入的成绩有误&quot;); &#125;else if(score&gt;=90 &amp;&amp; score&lt;=100) &#123; System.out.println(&quot;优秀&quot;); &#125;else if(score&gt;=80 &amp;&amp; score&lt;90) &#123; System.out.println(&quot;好&quot;); &#125;else if(score&gt;=70 &amp;&amp; score&lt;80) &#123; System.out.println(&quot;良&quot;); &#125;else if(score&gt;=60 &amp;&amp; score&lt;70) &#123; System.out.println(&quot;及格&quot;); &#125;else &#123; System.out.println(&quot;不及格&quot;); &#125; &#125;&#125; 练习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* 键盘录入月份的值，输出对应的季节。 春 3,4,5 夏 6,7,8 秋 9,10,11 冬 12,1,2 分析： A:键盘录入月份的值，所以我们要使用Scanner。 B:我们应该判断这个月份在那个季节，而这个判断情况较多，所以，用if语句格式3。 if语句的使用场景： A:针对表达式是一个boolean类型的判断 B:针对一个范围的判断*/import java.util.Scanner;class IfTest3 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //录入数据 System.out.println(&quot;请你输入一个月份:&quot;); int month = sc.nextInt(); //第三种格式实现即可 if(month&lt;1 || month&gt;12) &#123; System.out.println(&quot;你输入的月份有误&quot;); &#125;else if(month == 1) &#123; System.out.println(&quot;冬季&quot;); &#125;else if(month == 2) &#123; System.out.println(&quot;冬季&quot;); &#125;else if(month == 3) &#123; System.out.println(&quot;春季&quot;); &#125;else if(month == 4) &#123; System.out.println(&quot;春季&quot;); &#125;else if(month == 5) &#123; System.out.println(&quot;春季&quot;); &#125;else if(month == 6) &#123; System.out.println(&quot;夏季&quot;); &#125;else if(month == 7) &#123; System.out.println(&quot;夏季&quot;); &#125;else if(month == 8) &#123; System.out.println(&quot;夏季&quot;); &#125;else if(month == 9) &#123; System.out.println(&quot;秋季&quot;); &#125;else if(month == 10) &#123; System.out.println(&quot;秋季&quot;); &#125;else if(month == 11) &#123; System.out.println(&quot;秋季&quot;); &#125;else &#123; System.out.println(&quot;冬季&quot;); &#125; System.out.println(&quot;--------------&quot;); //这个程序确实是符合了我们的需求，但是就是看起来比较麻烦 //那么，我们能不能改进一下呢? //month == 3 //month == 4 //month == 5 //我们发现，上面三个都是春季。 //而他们本身每一个都是一个boolean表达式 //所以，我们就可以考虑使用逻辑运算符给他们连接起来改进 if(month&lt;1 || month&gt;12) &#123; System.out.println(&quot;你输入的月份有误&quot;); &#125;else if(month==3 || month==4 || month==5) &#123; System.out.println(&quot;春季&quot;); &#125;else if(month==6 || month==7 || month==8) &#123; System.out.println(&quot;夏季&quot;); &#125;else if(month==9 || month==10 || month==11) &#123; System.out.println(&quot;秋季&quot;); &#125;else &#123; System.out.println(&quot;冬季&quot;); &#125; System.out.println(&quot;--------------&quot;); //这个时候，程序代码以及可以了。 //但是呢，假如我要求你输入一个月份，判断是上半年还是下半年。 //这个时候，我们的判断条件连接就是6个boolean表达式 //我们可能还有更多的连接 //这个时候，其实我们还有另外的一种改进方案： //month == 3 //month == 4 //month == 5 //month&gt;=3 &amp;&amp; month&lt;=5 //用范围也是可以改进的。 if(month&lt;1 || month&gt;12) &#123; System.out.println(&quot;你输入的月份有误&quot;); &#125;else if(month&gt;=3 &amp;&amp; month&lt;=5) &#123; System.out.println(&quot;春季&quot;); &#125;else if(month&gt;=6 &amp;&amp; month&lt;=8) &#123; System.out.println(&quot;夏季&quot;); &#125;else if(month&gt;=9 &amp;&amp; month&lt;=11) &#123; System.out.println(&quot;秋季&quot;); &#125;else &#123; System.out.println(&quot;冬季&quot;); &#125; System.out.println(&quot;--------------&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/* 获取三个数据中的最大值 由此案例主要是为了讲解if语句是可以嵌套使用的。而且是可以任意的嵌套。*/class IfTest4 &#123; public static void main(String[] args) &#123; int a = 10; int b = 30; int c = 20; //三元实现 //int temp = (a&gt;b)? a: b; //int max = (temp&gt;c)? temp: c; //System.out.println(&quot;max:&quot;+max); //System.out.println(&quot;--------&quot;); //用if语句实现 int max; if(a &gt; b) &#123; if(a &gt; c) &#123; max = a; &#125;else &#123; max = c; &#125; &#125;else &#123; if(b &gt; c) &#123; max = b; &#125;else &#123; max = c; &#125; &#125; System.out.println(&quot;max:&quot;+max); &#125;&#125; 选择结构(switch语句)switch语句格式： 123456789101112switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; &#125; 执行流程： 123首先计算出表达式的值其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 Switch语句流程图代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* switch语句格式： switch(表达式) &#123; case 值1: 语句体1; break; case 值2: 语句体2; break; ... default: 语句体n+1; break; &#125; 格式的解释： switch:表示这是switch选择结构 表达式:这个地方的取值是有限定的 byte,short,int,char JDK5以后可以是枚举 JDK7以后可以是字符串 case:后面跟的是要和表达式进行比较的值 语句体:要执行的代码 break:表示中断，结束的意思，可以控制switch语句的结束。 default:当所有的值都和表达式不匹配的时候，就执行default控制的语句。其实它就相当于if语句的else。 面试题： byte可以作为switch的表达式吗? long可以作为switch的表达式吗? String可以作为switch的表达式吗? 案例： 键盘录入一个数据，根据这个数据，我们输出对应的星期? 键盘录入1,对应输出星期一 键盘录入2,对应输出星期二 ... 键盘录入7,对应输出星期日 分析： 1:键盘录入，用Scanner实现 2:判断我们既可以使用if语句，也可以使用我们要讲解的switch语句 注意： A:遇到左大括号缩进一个tab的位置。 B:关联不是很大的语句间空行*/import java.util.Scanner;class SwitchDemo &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //控制键盘录入数据 System.out.println(&quot;请输入一个数据(1-7):&quot;); int week = sc.nextInt(); //3 //switch判断语句 switch(week) &#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期日&quot;); break; default: System.out.println(&quot;你输入的数据有误&quot;); break; &#125; &#125;&#125; 注意事项 case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 default可以省略吗? 可以省略。一般不建议。除非判断的值是固定的。(单选题) break可以省略吗? 可以省略，一般不建议。否则结果可能不是你想要的 default的位置一定要在最后吗? 可以出现在switch语句任意位置。 switch语句的结束条件 遇到break 执行到程序的末尾 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* switch语句的注意事项： A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 B:default可以省略吗? 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。 特殊情况： case就可以把值固定。 A,B,C,D C:break可以省略吗? 可以省略，但是结果可能不是我们想要的。 会出现一个现象：case穿透。 最终我们建议不要省略 D:default一定要在最后吗? 不是，可以在任意位置。但是建议在最后。 E:switch语句的结束条件 a:遇到break就结束了 b:执行到末尾就结束了*/import java.util.Scanner;class SwitchDemo2 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //控制键盘录入数据 System.out.println(&quot;请输入一个数据(1-7):&quot;); int week = sc.nextInt(); //3 //定义常量 //int number = 3; //然后把case后面的值改为number，就会报错 //switch判断语句 switch(week) &#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期日&quot;); break; default: System.out.println(&quot;你输入的数据有误&quot;); //break; &#125; &#125;&#125; 选择结构(各自使用场景) 在做判断的时候，我们有两种选择，if语句和switch语句，那么，我们到底该如何选择使用那种语句呢? if语句使用场景： 针对结果是boolean类型的判断 针对一个范围的判断 针对几个常量值的判断 switch语句使用场景： 针对几个常量值的判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* 用switch语句实现键盘录入月份，输出对应的季节 分析： A:键盘录入一个月份，用Scanner实现 B:用switch语句实现即可 if语句和switch语句的区别? if语句： A:针对结果是boolean类型的判断 B:针对一个范围的判断 C:针对几个常量值的判断 switch语句： 针对几个常量值的判断*/import java.util.Scanner;class SwitchTest4 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //录入数据 System.out.println(&quot;请输入月份(1-12)：&quot;); int month = sc.nextInt(); /* switch(month) &#123; case 1: System.out.println(&quot;冬季&quot;); break; case 2: System.out.println(&quot;冬季&quot;); break; case 3: System.out.println(&quot;春季&quot;); break; case 4: System.out.println(&quot;春季&quot;); break; case 5: System.out.println(&quot;春季&quot;); break; case 6: System.out.println(&quot;夏季&quot;); break; case 7: System.out.println(&quot;夏季&quot;); break; case 8: System.out.println(&quot;夏季&quot;); break; case 9: System.out.println(&quot;秋季&quot;); break; case 10: System.out.println(&quot;秋季&quot;); break; case 11: System.out.println(&quot;秋季&quot;); break; case 12: System.out.println(&quot;冬季&quot;); break; default: System.out.println(&quot;你输入的月份有误&quot;); &#125; */ //这样写太麻烦了，我们使用一个我们不想使用的东西：case穿透 switch(month) &#123; case 1: case 2: case 12: System.out.println(&quot;冬季&quot;); break; case 3: case 4: case 5: System.out.println(&quot;春季&quot;); break; case 6: case 7: case 8: System.out.println(&quot;夏季&quot;); break; case 9: case 10: case 11: System.out.println(&quot;秋季&quot;); break; default: System.out.println(&quot;你输入的月份有误&quot;); &#125; &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】15-Java键盘录入","slug":"【JavaSe必知必会】15-Java键盘录入","date":"2018-11-15T07:42:41.000Z","updated":"2018-11-19T10:25:32.294Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】15-Java键盘录入/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】15-Java键盘录入/","excerpt":"","text":"键盘录入数据概述我们目前在写程序的时候，数据值都是固定的，但是实际开发中，数据值肯定是变化的，所以，我准备把数据改进为键盘录入，提高程序的灵活性。 如何实现键盘录入数据呢?(目前先记住使用) 导包(位置放到class定义的上面) import java.util.Scanner; 创建对象 Scanner sc = new Scanner(System.in); 接收数据 int x = sc.nextInt();代码演示 123456789101112131415161718192021222324252627282930/* 为了让程序的数据更符合开发的数据，我们就加入了键盘录入。 让程序更灵活一下。 那么，我们如何实现键盘数据的录入呢? A:导包 格式： import java.util.Scanner; 位置： 在class上面。 B:创建键盘录入对象 格式： Scanner sc = new Scanner(System.in); C:通过对象获取数据 格式： int x = sc.nextInt();*/import java.util.Scanner;class ScannerDemo &#123; public static void main(String[] args) &#123; //创建键盘录入数据对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请你输入一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;你输入的数据是：&quot;+x); &#125;&#125; 键盘录入数据练习 键盘录入两个数据，并对这两个数据求和，输出其结果 1234567891011121314151617181920212223/* 键盘录入练习： 键盘录入两个数据，并对这两个数据求和，输出其结果*/import java.util.Scanner;class ScannerTest &#123; public static void main(String[] args) &#123; //键盘录入两个数据，并对这两个数据求和，输出其结果 //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt(); //把键盘录入的数据进行相加即可 int sum = (x + y); System.out.println(&quot;sum:&quot;+sum); &#125;&#125; 键盘录入两个数据，获取这两个数据中的最大值 12345678910111213141516171819202122/* 键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值*/import java.util.Scanner;class ScannerTest2 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据：&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int b = sc.nextInt(); //获取这两个数据中的最大值 int max = (a &gt; b? a: b); System.out.println(&quot;max:&quot;+max); &#125;&#125; 键盘录入三个数据，获取这三个数据中的最大值 键盘录入两个数据，比较这两个数据是否相等 1234567891011121314151617181920212223242526272829303132333435363738394041/* 练习： 键盘录入三个数据，获取这三个数据中的最大值 键盘录入两个数据，比较这两个数据是否相等*/import java.util.Scanner;class ScannerTest3 &#123; public static void main(String[] args) &#123; //键盘录入三个数据，获取这三个数据中的最大值 //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据：&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int b = sc.nextInt(); System.out.println(&quot;请输入第三个数据：&quot;); int c = sc.nextInt(); //获取这三个数据中的最大值 int temp = ((a &gt; b)? a: b); int max = (temp &gt; c? temp : c); System.out.println(&quot;max:&quot;+max); System.out.println(&quot;------------------&quot;); //键盘录入两个数据 System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt(); //比较这两个数据是否相等 boolean flag = (x == y); System.out.println(&quot;flag:&quot;+flag); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】14-Java运算符之位运算符","slug":"【JavaSe必知必会】14-Java运算符之位运算符","date":"2018-11-15T07:41:05.000Z","updated":"2018-11-19T10:25:32.292Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】14-Java运算符之位运算符/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】14-Java运算符之位运算符/","excerpt":"","text":"概述基本用法 位运算是直接对二进制进行运算。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 位运算符： &amp;,|,^,~ &lt;&lt;,&gt;&gt;,&gt;&gt;&gt; 注意： 要做位运算符，首先要把数据转换为二进制。*/public class OperatorDemo&#123; public static void main(String[] args)&#123; int a = 3; int b = 4; System.out.println(3 &amp; 4); System.out.println(3 | 4); System.out.println(3 ^ 4); System.out.println(~3); &#125; &#125;/* 分析：因为是位运算，所以我们必须先把数据转换位二进制。 3的二进制：11 00000000 00000000 00000000 00000011 4的二进制：100 00000000 00000000 00000000 00000100 &amp;位与运算：有0则0。 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ------------------------------------- 00000000 00000000 00000000 00000000 结果是：0 |位或运算：有1则1. 00000000 00000000 00000000 00000011 |00000000 00000000 00000000 00000100 ------------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ^位异或运算：相同则0，不同则1. 00000000 00000000 00000000 00000011 ^00000000 00000000 00000000 00000100 ------------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ~按位取反运算符：0变1，1变0 ~00000000 00000000 00000000 00000011 11111111 11111111 11111111 11111100（补码） 补码：11111111 11111111 11111111 11111100 反码：11111111 11111111 11111111 11111011 原码：10000000 00000000 00000000 00000100 结果是：-4*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* &lt;&lt;:左移 左边最高位丢弃，右边补齐0 &gt;&gt;:右移 最高位是0，左边补齐0；最高为是1，左边补齐1 &gt;&gt;&gt;:无符号右移 无论最高位是0还是1，左边补齐0 面试题： 请用最有效率的方式写出计算2乘以8的结果? 2 * 8 2 &lt;&lt; 3*/class OperatorDemo3 &#123; public static void main(String[] args) &#123; //&lt;&lt; 把&lt;&lt;左边的数据乘以2的移动次幂 System.out.println(3 &lt;&lt; 2); //3*2^2 = 3*4 = 12; //&gt;&gt; 把&gt;&gt;左边的数据除以2的移动次幂 System.out.println(24 &gt;&gt; 2); //24 / 2^2 = 24 / 4 = 6 System.out.println(24 &gt;&gt;&gt; 2); System.out.println(-24 &gt;&gt; 2); System.out.println(-24 &gt;&gt;&gt; 2); &#125;&#125;/* 计算出3的二进制：11 00000000 00000000 00000000 00000011 (00)000000 00000000 00000000 0000001100 &gt;&gt;的移动： 计算出24的二进制：11000 原码：10000000 00000000 00000000 00011000 反码：11111111 11111111 11111111 11100111 补码：11111111 11111111 11111111 11101000 11111111 11111111 11111111 11101000 1111111111 11111111 11111111 111010(00) 补码 补码：1111111111 11111111 11111111 111010 反码：1111111111 11111111 11111111 111001 原码：1000000000 00000000 00000000 000110 结果：-6 &gt;&gt;&gt;的移动： 计算出24的二进制：11000 原码：10000000 00000000 00000000 00011000 反码：11111111 11111111 11111111 11100111 补码：11111111 11111111 11111111 11101000 11111111 11111111 11111111 11101000 0011111111 11111111 11111111 111010(00) 结果：*/ 异或运算符的特点123456789101112/* ^的特点：一个数据对另一个数据位异或两次，该数本身不变。*/public class OperatorDemo2 &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(a ^ b ^ b); //10 System.out.println(a ^ b ^ a); //20 &#125;&#125; 真题演练1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 面试题： 请自己实现两个整数变量的交换 注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。*/class OperatorTest &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); //方式1：使用第三方变量(开发中用的) /* int c = a; a = b; b = c; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); System.out.println(&quot;------------&quot;); */ //方式2：用位异或实现(面试用) //左边：a,b,a //右边：a ^ b /* a = a ^ b; b = a ^ b; //a ^ b ^ b = a a = a ^ b; //a ^ b ^ a = b System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); */ //方式3：用变量相加的做法 /* a = a + b; //a=30 b = a - b; //b=10 a = a - b; //a=20 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); */ //方式4：一句话搞定 b = (a+b) - (a=b); //b=30-20=10,a=20 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】13-Java运算符之三目运算符","slug":"【JavaSe必知必会】13-Java运算符之三目运算符","date":"2018-11-15T07:33:40.000Z","updated":"2018-11-19T10:25:32.290Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】13-Java运算符之三目运算符/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】13-Java运算符之三目运算符/","excerpt":"","text":"三目运算符概述三目运算符也可称为三元运算符。 格式==(关系表达式)?表达式1：表达式2；== 如果条件为true，运算后的结果是表达式1； 如果条件为false，运算后的结果是表达式2； 代码演示12345678910111213141516171819202122232425262728293031/* 单目运算符：~3 双目运算符：3 + 4 三目运算符： 格式：比较表达式?表达式1:表达式2; 比较表达式:结果是一个boolean类型。 执行流程： 根据比较表达式的计算返回一个true或者false。 如果是true，就把表达式1作为结果。 如果是false，就把表达式2作为结果。*/class OperatorDemo &#123; public static void main(String[] args) &#123; int x = 100; int y = 200; int z = ((x &gt; y)? x: y); //int z = ((x &lt; y)? x: y); //int z = ((x == y)? x: y); //报错 //int z = ((x = y)? x : y); System.out.println(&quot;z:&quot;+z); &#125;&#125; 真题演练123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 练习： 获取两个整数中的最大值 获取三个整数中的最大值 比较两个整数是否相同*/class OperatorTest &#123; public static void main(String[] args) &#123; //获取两个整数中的最大值 int x = 100; int y = 200; int max = (x &gt; y? x: y); System.out.println(&quot;max:&quot;+max); System.out.println(&quot;--------&quot;); //获取三个整数中的最大值 int a = 10; int b = 30; int c = 20; //分两步： //A:先比较a,b的最大值 //B:拿a,b的最大值在和c进行比较 int temp = ((a &gt; b)? a: b); //System.out.println(temp); int max1 = (temp &gt; c? temp: c); System.out.println(&quot;max1:&quot;+max1); //一步搞定 //int max2 = (a &gt; b)?((a &gt; c)? a: c):((b &gt; c)? b: c); //这种做法不推荐。 //int max2 = a &gt; b?a &gt; c? a: c:b &gt; c? b: c; //System.out.println(&quot;max2:&quot;+max2); System.out.println(&quot;--------&quot;); //比较两个整数是否相同 int m = 100; int n = 200; //boolean flag = (m == n)? true: false; boolean flag = (m == n); System.out.println(flag); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】12-关系运算符与逻辑运算符","slug":"【JavaSe必知必会】12-关系运算符与逻辑运算符","date":"2018-11-15T07:32:16.000Z","updated":"2018-11-19T10:25:32.290Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】12-关系运算符与逻辑运算符/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】12-关系运算符与逻辑运算符/","excerpt":"","text":"关系运算符概述 注1：比较运算符的结果都是boolean型，也就是要么是true，要么是false。 注2：比较运算符“==”不能误写成“=” 。代码演示 123456789101112131415161718192021222324252627282930313233343536373839/* 比较运算符： ==,!=,&gt;,&gt;=,&lt;,&lt;= 特点： 无论你的操作是简单还是复杂，结果是boolean类型。 注意事项： &quot;==&quot;不能写成&quot;=&quot;。*/class OperatorDemo &#123; public static void main(String[] args) &#123; int x = 3; int y = 4; int z = 3; System.out.println(x == y); System.out.println(x == z); System.out.println((x+y) == (x+z)); System.out.println(&quot;------------&quot;); System.out.println(x != y); System.out.println(x &gt; y); System.out.println(x &gt;= y); System.out.println(x &lt; y); System.out.println(x &lt;= y); System.out.println(&quot;------------&quot;); int a = 10; int b = 20; //boolean flag = (a == b); //boolean flag = (a = b); //这个是有问题的，不兼容的类型 //System.out.println(flag); int c = (a = b); //把b赋值给a，然后把a留下来 System.out.println(c); &#125;&#125; 逻辑运算符概述 逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。 “&amp;”和“&amp;&amp;”的区别： 单&amp;时，左边无论真假，右边都进行运算； 双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 “|”和“||”的区别同理，双或时，左边为真，右边不参与运算。 异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* 逻辑运算符： &amp;,|,^,! &amp;&amp;,|| 特点： 逻辑运算符一般用于连接boolean类型的表达式或者值。 表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。 算术表达式：a + b 比较表达式：a == b 结论： &amp;逻辑与:有false则false。 |逻辑或:有true则true。 ^逻辑异或:相同为false，不同为true。 举例：情侣关系。男男,男女,女男,女女 !逻辑非:非false则true，非true则false。 特点：偶数个不改变本身。*/class OperatorDemo &#123; public static void main(String[] args) &#123; int a = 3; int b = 4; int c = 5; //&amp;逻辑与 System.out.println((a &gt; b) &amp; (a &gt; c)); //false &amp; false = false System.out.println((a &gt; b) &amp; (a &lt; c)); //false &amp; true = false System.out.println((a &lt; b) &amp; (a &gt; c)); //true &amp; false = false System.out.println((a &lt; b) &amp; (a &lt; c)); //true &amp; true = true System.out.println(&quot;---------------&quot;); //|逻辑或 System.out.println((a &gt; b) | (a &gt; c)); //false | false = false System.out.println((a &gt; b) | (a &lt; c)); //false | true = true System.out.println((a &lt; b) | (a &gt; c)); //true | false = true System.out.println((a &lt; b) | (a &lt; c)); //true | true = true System.out.println(&quot;---------------&quot;); //^逻辑异或 System.out.println((a &gt; b) ^ (a &gt; c)); //false ^ false = false System.out.println((a &gt; b) ^ (a &lt; c)); //false ^ true = true System.out.println((a &lt; b) ^ (a &gt; c)); //true ^ false = true System.out.println((a &lt; b) ^ (a &lt; c)); //true ^ true = false System.out.println(&quot;---------------&quot;); //!逻辑非 System.out.println(!(a &gt; b)); //!false = true System.out.println(!(a &lt; b)); //!true = false System.out.println(!!(a &gt; b)); //!!false = false System.out.println(!!!(a &gt; b)); //!!false = true &#125;&#125; 123456789101112131415161718192021222324252627282930313233/* &amp;&amp;和&amp;的区别? 同理||和|的区别? A:最终结果一样。 B:&amp;&amp;具有短路效果。左边是false，右边不执行。 开发中常用的逻辑运算符： &amp;&amp;,||,!*/class OperatorDemo2 &#123; public static void main(String[] args) &#123; int a = 3; int b = 4; int c = 5; //&amp;&amp;双与 System.out.println((a &gt; b) &amp;&amp; (a &gt; c)); //false &amp;&amp; false = false System.out.println((a &gt; b) &amp;&amp; (a &lt; c)); //false &amp;&amp; true = false System.out.println((a &lt; b) &amp;&amp; (a &gt; c)); //true &amp;&amp; false = false System.out.println((a &lt; b) &amp;&amp; (a &lt; c)); //true &amp;&amp; true = true System.out.println(&quot;----------------&quot;); int x = 3; int y = 4; //boolean b1 = ((x++ == 3) &amp; (y++ == 4)); //boolean b1 = ((x++ == 3) &amp;&amp; (y++ == 4)); //boolean b1 = ((++x == 3) &amp; (y++ == 4)); boolean b1 = ((++x == 3) &amp;&amp; (y++ == 4)); System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y); System.out.println(b1); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】11-Java运算符之算术运算符","slug":"【JavaSe必知必会】11-Java运算符之算术运算符","date":"2018-11-15T07:29:21.000Z","updated":"2018-11-19T10:25:32.287Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】11-Java运算符之算术运算符/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】11-Java运算符之算术运算符/","excerpt":"","text":"运算符 运算 对常量和变量进行操作的过程称为运算。 运算符 对常量和变量进行操作的符号称为运算符 操作数 参与运算的数据称为操作数 用运算符把常量或者变量连接起来符号java语法的式子就可以称为表达式。 不同运算符连接的式子体现的是不同类型的表达式。 1234567举例： int a = 3 + 4; 这是做了一个加法运算 +就是运算符，是算术运算符，我们还有其他很多的运算符 3，4就是参与运算的操作数据 3 + 4整体其实就是一个算数表达式 运算符类别 算术运算符 赋值运算符 比较运算符 逻辑运算符 位运算符 三目运算符算术运算符基本用法 123456789101112131415161718192021222324252627282930313233/* 运算符： 就是对常量和变量进行操作的符号。 分类：算术运算符，赋值运算符，比较运算符，逻辑运算符，位运算符，三目运算符 算术运算符： +,-,*,/,%,++,-- 注意事项： A:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型 B:/获取的是除法操作的商，%获取的是除法操作的余数*/class OperatorDemo &#123; public static void main(String[] args) &#123; //定义变量 int x = 3; //把3赋值给int类型的变量x int y = 4; System.out.println(x+y); System.out.println(x-y); System.out.println(x*y); System.out.println(x/y); //整数相除只能得到整数 //我就想得到小数，该肿么办呢? //只需要把操作的数据中任意的一个数据变为浮点数 System.out.println(x*1.0/y); //%的应用 System.out.println(x%y); //得到的是余数 &#125;&#125; ++和–的应用 单独使用效果相同 参与运算使用,在操作数的前后效果不同 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* ++,--运算符的使用： 单独使用： 放在操作数的前面和后面效果一样。(这种用法是我们比较常见的) 参与运算使用： 放在操作数的前面，先自增或者自减，然后再参与运算。 放在操作数的后面，先参与运算，再自增或者自减。 作用：就是对变量进行自增1或者自减1。*/public class OperatorDemo2 &#123; public static void main(String[] args) &#123; //定义两个变量 int x = 3; int y = 4; //字符串的拼接 //System.out.println(&quot;x:&quot;+x); //System.out.println(&quot;y:&quot;+y); System.out.println(&quot;x:&quot;+x+&quot;,y:&quot;+y); //单独使用 //x++; //y--; ++x; --y; //System.out.println(x); System.out.println(&quot;x:&quot;+x+&quot;,y:&quot;+y); //意外的类型,常量是不可以这样做的 //System.out.println(10++); System.out.println(&quot;-------------------&quot;); //参与运算使用 int a = 3; int b = 4; //int c = a++; //int d = b--; int c = ++a; int d = --b; System.out.println(&quot;a:&quot;+a); //4, 4 System.out.println(&quot;b:&quot;+b); //3, 3 System.out.println(&quot;c:&quot;+c); //3, 4 System.out.println(&quot;d:&quot;+d); //4, 3 &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* ++,--的练习题 第一题： int a = 10; int b = 10; int c = 10; a = b++; c = --a; b = ++a; a = c--; 请分别计算出a,b,c的值 第二题： int x = 4; int y = (x++)+(++x)+(x*10); 请分别计算出x,y的值*/public class OperatorTest &#123; public static void main(String[] args) &#123; int a = 10; int b = 10; int c = 10; a = b++; //a=10,b=11,c=10 c = --a; //a=9,b=11,c=9 b = ++a; //a=10,b=10,c=9 a = c--; //a=9,b=10,c=8 System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); System.out.println(&quot;c:&quot;+c); System.out.println(&quot;--------------&quot;); int x = 4; int y = (x++)+(++x)+(x*10); //4+6+60 //x=5,6 System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y); &#125;&#125; 运算符的优先级 ==如果在程序中，要改变运算顺序，可以使用()。== +运算符的用法12345678910111213141516171819202122/* +的用法： A:加法 B:正号 C:字符串连接符*/class OperatorDemo3 &#123; public static void main(String[] args) &#123; //加法 System.out.println(3+4); //正号 System.out.println(+4); System.out.println(&apos;a&apos;); System.out.println(&apos;a&apos;+1); //这里是加法 //字符串连接符 System.out.println(&quot;hello&quot;+&apos;a&apos;+1); System.out.println(&apos;a&apos;+1+&quot;hello&quot;); &#125;&#125; 赋值运算符 符号：= , +=, -=, *=, /=, %= =为基本的赋值运算符，其他的为扩展的赋值运算符 = 赋值号 +=加赋值 把左边和右边的结果赋值给左边。 注意：====左边不能是常量==== 1234567891011121314151617181920212223242526/* 赋值运算符： 基本赋值运算符：= 把=右边的数据赋值给左边。 扩展的赋值运算符：+=，-=，/=，%=*/public class OperatorDemo4&#123; public static void main(String[] args)&#123; //定义一个变量 int x = 10; //其他用法 int a,b; a = b = 10; System.out.println(a); System.out.println(b); System.out.println(&quot;-------------------------------&quot;); //定义一个变量 int y = 10; y += 10;//等价于y = y + 10; System.out.println(y); &#125;&#125; 面试题解析12345678910111213141516171819202122232425/* 面试题： short s=1;s = s+1; short s=1;s+=1; 上面两个代码有没有问题，如果有，那里有问题。 为什么第二个木有问题呢? 扩展的赋值运算符其实隐含了一个强制类型转换。 s += 1; 不是等价于 s = s + 1; 而是等价于 s = (s的数据类型)(s + 1);*/class OperatorTest &#123; public static void main(String[] args) &#123; //short s = 1; //s = s + 1; //System.out.println(s); short s = 1; s += 1; //好像是 s = s + 1; System.out.println(s); &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】10-数据类型转换与运算","slug":"【JavaSe必知必会】10-数据类型转换与运算","date":"2018-11-15T03:24:00.000Z","updated":"2018-11-19T10:25:32.285Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】10-数据类型转换与运算/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】10-数据类型转换与运算/","excerpt":"","text":"数据类型转换默认转换 +是一个运算符, 我们应该能够看懂，做数据的加法。 boolean类型不能转换为其他的数据类型 默认转换 byte,short,char—int—long—float—double byte,short,char相互之间补转换，他们参与运算首先转换为int类型 12345678910111213141516171819202122232425262728293031323334/* +是一个运算符(我们等会讲解)。做加法运算的。 一般来说，我们在运算的时候，要求参与运算的数据类型必须一致。 注意： boolean类型不能转换为其他的数据类型 默认转换(从小到大的转换) A:byte,short,char—int—long—float—double B:byte,short,char相互之间不转换，他们参与运算首先转换为int类型*/class DataTypeDemo3 &#123; public static void main(String[] args) &#123; //直接输出的方式做加法 //System.out.println(3 + 4); //两个int类型做加法 int x = 3; int y = 4; int z = x + y; System.out.println(z); //定义一个byte类型，一个int类型，做加法 byte a = 3; int b = 4; System.out.println(a + b); //可能损失精度 //byte c = a + b; int c = a + b; System.out.println(c); &#125;&#125; 不同数据类型变量参与运算图解 强制转换 目标类型 变量名=(目标类型)(被转换的数据); 1234567891011121314151617181920212223242526/* 强制转换： 从大的数据类型到小的数据类型。 格式： 目标数据类型 变量 = (目标数据类型) (被转换的数据); 注意： 不要随意的去使用强制转换，因为它隐含了精度损失问题。*/class DataTypeDemo4 &#123; public static void main(String[] args) &#123; byte a = 3; int b = 4; //这个肯定没有问题 //int c = a + b; //byte c = 7; //这个是有问题的 //byte c = a + b; //用强制类型转换改进 byte c = (byte) (a + b); System.out.println(c); &#125;&#125; 思考题1234567891011121314151617181920212223/* 思考题1：请问下面这个有没有问题 double d = 12.345; float f = d; 思考题2：看看下面两个定义有没有区别呢? float f1 = (float)12.345; float f2 = 12.345f; f1其实是通过一个double类型转换过来的。 而f2本身就是一个float类型。*/class DataTypeDemo5 &#123; public static void main(String[] args) &#123; //把double赋值给float，加了强制类型转换 double d = 12.345; float f = (float)d; //看看下面两个定义有没有区别呢? float f1 = (float)12.345; float f2 = 12.345F; &#125;&#125; 常量运算与变量运算的区别123456789101112131415161718192021/* 面试题： byte b1=3,b2=4,b; b=b1+b2; b=3+4; 哪句是编译失败的呢？为什么呢？ b = b1 + b2;是有问题的。 因为变量相加，会首先看类型问题，最终把结果赋值的也会考虑类型问题。 常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才报错。*/class DataTypeDemo6 &#123; public static void main(String[] args) &#123; //定义了三个byte类型的变量，b1，b2，b3 //b1的值是3，b2的值是4，b没有值 byte b1 = 3,b2 = 4,b; //b = b1 + b2; //这个是类型提升，所有有问题 b = 3 + 4; //常量，先把结果计算出来，然后看是否在byte的范围内，如果在就不报错。 &#125;&#125; 数据溢出原理解析1234567891011121314151617181920212223242526272829303132333435363738/* byte b = 130;有没有问题?如果我想让赋值正确，可以怎么做?结果是多少呢? 练习：byte b = (byte)300;*/class DataTypeDemo7 &#123; public static void main(String[] args) &#123; //因为byte的范围是：-128到127。 //而130不在此范围内，所以报错。 //byte b = 130; //我们可以使用强制类型转换 byte b = (byte) 130; //结果是多少呢? System.out.println(b); &#125;&#125;/* 分析过程： 我们要想知道结果是什么，就应该知道是如何进行计算的。 而我们又知道计算机中数据的运算都是补码进行的。 而要得到补码，首先要计算出数据的二进制。 A:获取130这个数据的二进制。 00000000 00000000 00000000 10000010 这是130的原码，也是反码，还是补码。 B:做截取操作，截成byte类型的了。 10000010 这个结果是补码。 C:已知补码求原码。 符号位 数值位 补码： 1 0000010 反码： 1 0000001 原码： 1 1111110*/ 常用字符与ASCII代码对照表 字符参与运算1234567891011121314151617/* 看程序写结果 通过字符和一个整数相加，我们给出一张表：ASCII码表。 通过看完这张表以后，我们要记住三个值： &apos;a&apos; 97 &apos;A&apos; 65 &apos;0&apos; 48*/class DataTypeDemo8 &#123; public static void main(String[] args) &#123; //直接输出一个字符 System.out.println(&apos;a&apos;); //a //输出一个字符和一个整数做加法 System.out.println(&apos;a&apos;+1); //98 &#125;&#125; 字符串参与运算1234567891011121314/* 看程序写结果 字符串数据和其他数据做+，结果是字符串类型。 这里的+不是加法运算，而是字符串连接符。*/class DataTypeDemo9 &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello&quot;+&apos;a&apos;+1); //helloa1 System.out.println(&apos;a&apos;+1+&quot;hello&quot;); //98hello System.out.println(&quot;5+5=&quot;+5+5); //5+5=55 System.out.println(5+5+&quot;=5+5&quot;); //10=5+5 &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】09-Java数据类型划分","slug":"【JavaSe必知必会】09-Java数据类型划分","date":"2018-11-15T03:22:40.000Z","updated":"2018-11-19T10:25:32.283Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】09-Java数据类型划分/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】09-Java数据类型划分/","excerpt":"","text":"前言在经历了之前章节基础数学进制相关内容的洗礼之后，是不感觉自己的逻辑思维高了一大截？那本章我们要说的数据类型，肯定对大家来说就是小case了！那我们开始新章节的学习吧！ 变量变量概述 在程序执行的过程中，在某个范围内其值可以发生改变的量 理解：如同数学中的未知数 从本质上讲，变量其实是内存中的一小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请（声明），然后必须进行赋值（填充内容），才能使用。 为什么要定义变量呢用来不断的存放同一类型的常量，并可以重复使用 变量的组成规则： A：必须对其进行限定。如何限定？用数据类型。 B：我们在运算的时候，不可能拿着这个空间去运算，我们真正运算时使用的是该空间&gt;的值，我们就得给空间起一个名字：变量名 C：即使你有数据类型，你有变量名，但是如果没有值，这个空间就是一个垃圾空间，&gt;没有任何意义。所有需要初始化值。 定义变量的格式数据类型 变量名 = 初始化值; 注意：格式是固定的，记住格式，以不变应万变 数据类型 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存总分配了不同大小的内存空间 有效数字：具体地说，是指在分析工作中实际能够测量到的数字。所谓能够测量到的是包括最后一位估计的，不确定的数字。对于一个近似数，从左边第一个不是0的数字起，到精确到的位数止，所有的数字都叫做这个数的有效数字。 数据类型的概述和分类 定义不同数据类型的变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* 数据类型：Java是一种强类型的语言，针对每一种数据都定义了明确的数据类型。 数据类型分类： A:基本数据类型 B:引用数据类型(类,接口,数值) 基本数据类型:4类8种 A:整数 占用字节数 byte 1 short 2 int 4 long 8 B:浮点数 float 4 double 8 C:字符 char 2 D:布尔 boolean 1 注意： 整数默认是int类型 浮点数默认是double类型。 长整型后缀用L或者l标记。建议使用L。 单精度浮点数用F或者f标记。建议使用F。*/class DataTypeDemo &#123; public static void main(String[] args) &#123; //定义变量的格式： //数据类型 变量名 = 初始化值; //定义一个字节变量 byte b = 10; System.out.println(10); System.out.println(b); //定义一个短整型变量 short s = 100; System.out.println(s); //定义一个整型变量 int i = 1000; System.out.println(i); //超过了int的范围 //int j = 1000000000000; long j = 1000000000000L; //long j = 100L; System.out.println(j); //定义浮点数据变量 float f = 12.345F; System.out.println(f); double d = 12.345; System.out.println(d); //定义字符变量 char ch = &apos;a&apos;; System.out.println(ch); //定义布尔变量 boolean flag = true; System.out.println(flag); &#125;&#125; 使用变量的注意事项作用域 变量定义在哪一级大括号中，哪个大括号的范围就是这个变量的作用域。相同的作用域中不能定义两个同名变量。 初始化值 没有初始化值不能直接使用 在一行上建议只定义一个变量 可以定义多个，但是不建议 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 使用变量的时候要注意的问题： A:作用域 变量定义在哪个大括号内，它就在这个大括号内有效。 并且，在同一个大括号内不能同时定义同名的变量。 B:初始化值 没有初始化值的变量不能直接使用。 你只要在使用前给值就行，不一定非要在定义的时候立即给值。 推荐在定义的时候给值。 定义变量的格式： a:数据类型 变量名 = 初始化值; b:数据类型 变量名; 变量名 = 初始化值; C:在一行上建议只定义一个变量 可以定义多个，但是不建议*/class DataTypeDemo2 &#123; public static void main(String[] args) &#123; //定义变量 int x = 100; //错误，不能有同名的 //int x = 200; //定义变量必须给值 //int y; //System.out.println(y); int z; z = 100; System.out.println(z); //在一行上定义多个变量 //int a = 10; int b = 20; int c = 30; //上面的写法可以，但是不建议。 int a = 10; int b = 20; int c = 30; //int d, e; //d = 40; //e = 50; //int f,int g; //错误 //int h; int i; //正确 &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】08-原码反码补码","slug":"【JavaSe必知必会】08-原码反码补码","date":"2018-11-15T03:21:13.000Z","updated":"2018-11-19T10:25:32.280Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】08-原码反码补码/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】08-原码反码补码/","excerpt":"","text":"前言通过上一章节的内容我们已经掌握了不同进制间的转化，但是我们可以发现，我们做的都是一些正数的转化，那在计算机中，负数如何表示与运算呢？这就不得不提一下我们计算机的“码三少“：原码反码补码了。 有符号数据表示法 在计算机内，有符号数有3种表示法：原码、反码和补码。所有数据的运算都是采用补码进行的。 原码就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 反码正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码正数的补码与其原码相同；负数的补码是在其反码的末位加1。 1234567891011121314151617181920212223242526272829303132有符号数据表示法 在技术算计内，有符号数据有3种表示法：原码、反码、补码。 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 反码 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 正数的补码与其原码相同；负数的补码是在其反码的末位加1。 我准备用原码、反码、补码分别来表示+7，-7. 首先我们要得到7的二进制：111 原码： 正数的原码最高位是0. 负数的原码最高位为1. 其他的数值位. 符号位 数值位 +7 0 0000111 -7 1 0000111 反码： 正数的反码与其原码相同。 负数的反码与原码符号位相同，数值位要取反，就是0变1，1变0. 符号位 数值位 +7 0 0000111 -7 1 1111000 补码： 正数的补码与原码相同。 负数的补码是在反码的基础上加1. 符号位 数值位 +7 0 0000111 -7 1 1111001","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】07-进制的转换","slug":"【JavaSe必知必会】07-进制的转换","date":"2018-11-15T03:20:09.000Z","updated":"2018-11-19T10:25:32.278Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】07-进制的转换/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】07-进制的转换/","excerpt":"","text":"前言在上一节的文章中我们讲解了进制的概述与不同进制的表现形式，我猜肯定还有很多人懵懵懂懂的。老铁，莫慌，这是正常现象，接着往下看，你会发现，进制这小子算个啥子咧！ 其他进制到十进制通过十进制推出结论1234567891011121314其他进制到十进制的转换 十进制 十进制 12345 = 10000 + 2000 + 300 + 40 + 5 = 1*10^4 + 2*10^3 + 3*10^2 + 4*10^1 +5*10^0 = 10000 + 2000 + 300 + 40 + 5 = 12345 系数：每一个位上的数据值本身就是系数 基数：x进制的基数就是x 权：我们针对每一个位上的数据进行编号，从右边，并且是从0开始编号， 这个编号就是该位上的数据的权值 每一个位上的系数*基数^权次幂相加 把0b100,0100,0x100转换成十进制1234567891011121314二进制：100 十进制：4100 =1*2^2 + 0*2^1 + 0*2^0 =4 + 0 + 0 =4八进制：100 十进制：64100 =1*8^2 + 0*8^1 + 0*8^0 =64 + 0 + 0 =64 十六进制：100 十进制：256100 =1*16^2 + 0*16^1 + 0*16^0 =256 + 0 + 0 =256 十进制到其他进制通过十进制推出结论12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849十进制转其他进制 除基取余，直到商为0，余数反转 十进制 十进制 12345 12345 商 余数 12345 ————— = 1234 % 5 10 1234 ————— = 123 % 4 10 123 ————— = 12 % 3 10 12 ————— = 1 % 2 10 1 ————— = 0 % 1 10 十进制：20 二进制：10100 20 ——— = 10 % 0 2 10 ——— = 5 % 0 2 5 ——— = 2 % 1 2 2 ——— = 1 % 0 2 1 ——— = 0 % 1 2 结论：==除基取余，直到商为0，余数反转==。 十进制和二进制的快速转换8421码 8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二进制代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。 123456789101112二进制 1 1 1 1 1 1 1 1十进制 128 64 32 16 8 4 2 1二进制到十进制的转换： 1010100 = 64 + 16 + 4 = 84 十进制到二进制的转换： 100 = 0b1100100 问题：任意的x进制到y进制的转换，如何转？ x进制 ---&gt; 十进制 十进制 ---&gt; y进制 二进制和八进制，十六进制如何转换 以十进制作为桥梁 二进制到八进制 3位组合 二进制到十六进制 4位组合 12345678910111213141516二进制到八进制，十六进制 A:二进制到十进制，十进制到八进制或十六进制 B：拆分组合法0b1011001 八进制方式1： 0b1011001 = 64+16+8+1 =89 89 = 0131 89/8=11 1 11/8=1 3 1/8=0 1方式2： 0b1011001 001 011 001 1 3 1 0131","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】06-Java常量与进制概述","slug":"【JavaSe必知必会】06-Java常量与进制概述","date":"2018-11-15T03:19:07.000Z","updated":"2018-11-19T10:25:32.276Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】06-Java常量与进制概述/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】06-Java常量与进制概述/","excerpt":"","text":"前言上一节我们介绍了注释、关键字与标识符，本章给大家介绍一下常量，准备好没有，要开车了！ 常量常量概述 在程序执行的过程中其值不可以发生改变 Java中常量分类 字面值常量 自定义常量(面向对象部分讲) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 常量： 在程序执行过程中，其值不发生改变的量。 分类： A:字面值常量 B:自定义常量(后面讲) 字面值常量 A:字符串常量 用双引号括起来的内容。 举例：&quot;hello&quot;,&quot;world&quot;,&quot;HelloWorld&quot; B:整数常量 所有的整数 举例：100,200 C:小数常量 所有的小数 举例：10.23,110.11 D:字符常量 用单引号括起来的内容 举例：&apos;a&apos;,&apos;A&apos;,&apos;0&apos; 错误的：&apos;ab&apos; E:布尔常量 比较特殊 举例：true,false F:空常量 后面讲 举例：null*/class ConstantDemo &#123; public static void main(String[] args) &#123; //字符串常量的输出 System.out.println(&quot;hello&quot;); //整数常量的输出 System.out.println(100); //小数常量的输出 System.out.println(100.10); //字符常量的输出 System.out.println(&apos;a&apos;); System.out.println(&apos;A&apos;); System.out.println(&apos;0&apos;); //这个是有问题的 //System.out.println(&apos;ab&apos;); //布尔常量的输出 System.out.println(true); System.out.println(false); &#125;&#125; 进制进制概述与图解概述Java针对整数常量提供了4种表现形式 二进制 八进制 十进制 十六进制 进制：就是进位制，是人们规定的一种进位方法。对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。 二进制的由来：任何数据在计算机中都是以二进制的形式存在的。二进制早期由电信号开关演变而来。一个整数在内存中一样也是二进制的，但是使用一大串的1或者0组成的数值进行使用很麻烦。所以就想把一大串缩短点，将二进制中的三位用一位表示。这三位可以取到的最大值就是7.超过7就进位了，这就是八进制。但是对于过长的二进制变成八进制还是较长，所以出现的用4个二进制位表示一位的情况，四个二进制位最大是15，这就是十六进制。==规律，进制越大，表现形式越短。== 图解 不同进制数据的表现形式不同进制的数据组成 二进制 由0,1组成。以0b开头 八进制 由0,1,…7组成。以0开头 十进制 由0,1,…9组成。整数默认是十进制的 十六进制 由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头代码演示 12345678910111213141516/* 不同进制的数据表现： 二进制：由0，1组成。以0b开头。 八进制：由0,1,...7组成。以0开头。 十进制：由0,1,...9组成。默认整数是十进制。 十六进制：由0,1,...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。*/class JinZhiDemo &#123; public static void main(String[] args) &#123; System.out.println(100); //十进制 System.out.println(0b100); //二进制 System.out.println(0100); //八进制 System.out.println(0x100); //十六进制 &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】05-Java程序基本概念","slug":"【JavaSe必知必会】05-Java程序基本概念","date":"2018-11-15T03:17:50.000Z","updated":"2018-11-19T10:25:32.274Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】05-Java程序基本概念/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】05-Java程序基本概念/","excerpt":"","text":"前言在前面的内容中，我们介绍了Java的环境搭建，也敲了我们学习过程中的第一个Java程序，但是，我想很多人暂时还对之前敲的那段代码心存疑问。没有关系，接下来，我们就对其进行抽丝剥茧，深入解析，你会发现，原来Java如此简单。 注释注释概述及其分类 注释概述 用于解释说明程序的文字 Java中注释分类格式 单行注释 格式： //注释文字 多行注释 格式： / 注释文字 / 文档注释 格式：/* 注释文字 /注释用途 注释是一个程序员必须要具有的良好编程习惯。 ==初学者编写程序可以养成习惯：先写注释再写代码==。 将自己的思想通过注释先整理出来，在用代码去体现。 因为代码仅仅是思想的一种体现形式而已。注释代码整合案例演示 12345678910111213141516/***我们要写一个输出呆萌钟很帅的程序*//*分析思路： 1、首先要定义一个类：ZhushiDemo 2、程序要被jvm调用，需要定义main方法 3、程序要想输出结果，必须要有输出语句*/public class ZhushiDemo&#123;//定义一个类，public与class都是定义类用的关键字，后面跟的是类名 //定义main方法 public static void main(String[] args)&#123; //输出语句基本格式，双引号里面的内容就是你们想要输出的内容 System.out.println(&quot;呆萌钟很帅&quot;); System.out.println(&quot;我们也很帅&quot;); &#125;&#125; 注释总结 解释说明程序，提高程序的阅读性可以帮助我们排错 后面我们会讲解更高级的排错方式标识符与关键字关键字 关键字概述 被Java语言赋予特定含义的单词 关键字特点 组成关键字的字母全部小写 关键字注意事项 goto和const作为保留字存在,目前并不使用 类似Notepad++这样的高级记事本,针对关键字有特殊的颜色标记，非常直观Java中的关键字列表标识符 标识符概述 就是给类,接口,方法,变量等起名字时使用的字符序列 组成规则 英文大小写字母 数字字符 $和_ 注意事项 不能以数字开头 不能是Java中的关键字 区分大小写标识符命名示例 包(其实就是文件夹,用于解决相同类名问题) 字母全小写,demo.biaoshifu、demo.guanjianzi 类或者接口 单个单词：首字母大写，Name 两个或多个单词：每个单词首字母大写，ClassName、InterfaceName 方法和变量 单个单词：首字母大写，Name 两个或多个单词：每个单词首字母大写，ClassName、InterfaceName 常量一个单词和和多个单词分别举例 单个单词：所有字母大写 多个单词：所有字母大写，单词与单词之间用下划线分割","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】04-编写第一个Java程序","slug":"【JavaSe必知必会】04-编写第一个Java程序","date":"2018-11-15T03:14:18.000Z","updated":"2018-11-19T10:25:32.272Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】04-编写第一个Java程序/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】04-编写第一个Java程序/","excerpt":"","text":"前言现在，大家应该都已经安装好jdk环境和环境变量配置好了吧！是不是已经跃跃欲试，按耐不住心中的小激动了？那我们现在就来写我们java学习生涯中的第一个java程序。 文件相关设置为了方便后面大家的学习呢？有一点大家还是需要提前设置一下的，就是文件的相关设置（如果已经做过相关设置，跳过这一段）首先随便进入一个文件夹，我们会发现文件夹下的文件都只有文件名，却没有文件是属于那种类型的后缀名，设置成功之后应该是长这样的，先给大家看设置成功的样子 如果你的已经是长这样了，那就不用设置啦，说明已经设置过了，如果不是长上面那样的同学，那你们就需要再往下看咯！ 首先我们看一下文件夹上方的工具栏，是不是有一个工具选项，点击它，然后选择文件夹选项 选择查看，然后把显示隐藏的文件选择上，把隐藏已知文件的扩展名这个√去掉，搞定之后点击确定就大功告成了！ 文本编辑器编写代码可能很多朋友在看别的程序员敲代码的时候都是用各种炫酷的集成IDE开发工具，好黑科技的感觉对不对？不用羡慕他们，后面我们也会变得炫酷。那如何才能以后变得炫酷呢？骚年，莫急，现在我们就要介绍炫酷coding的开山鼻祖——文本编辑器直接直接写代码。 啥是文本编辑器？(⊙o⊙)…额，应该都知道吧。那我们就直接说咯！ 首先自己选择一个文件夹，最好新建一个专门用于存储我们自己写的代码的文件夹，进入文件夹之后点击鼠标右键，选择新建，然后选择文本文档 把文件名重命名为HelloJava，把txt后缀名改为java，命名完成出现下图提示点击是 创建完成之后，我们会发现文件的类型变为Java类型，我们选中该文件，点击鼠标右键，选择编辑，打开文本编辑框后输入如下内容 编辑完成后关闭文件回到该文件所在目录（即文件夹），然后在当前目录打开命令行DOS窗口，输入命令javac HelloJava.java,然后回车，发现命令行DOS窗口没啥反应，但是如果你仔细一点，你会发现，当前目录下多了一个叫做HelloJava.class的文件，如下图 好，我先不解释它是啥，因为后续会说到，如果出现这一步，我们继续在DOS窗口输入下一条命令：java HelloJava，回车，是不是发现此时窗口里有反应了，多出了两行文字 这两行内容其实就是我们刚才在文本编辑器中的代码让其打出的，这就是用文本编辑器的方式编写运行代码的方式！ Java9的JShell方式编写代码什么是jshell呢？那我就简单的先给大家介绍一下。 jshell是Java 9 新增的一个脚本工具，意思是可以在命令行里直接运行java的代码，而无需创建Java文件，然后再编译，最后运行。我觉得jshell的好处就是即写即得，平常只想看看几行代码运行的结果是怎么样的，有了jshell就方便多了，直接在命令行上敲。 那如何使用它呢？ 打开DOS命令窗口，输入命令：jshell，回车，稍等几秒钟就会看到JShell启动成功的欢迎提示语，出现下图说明启动成功！ 然后，怎么用呢？比如，输入 1+1: 结果输出$1 ==&gt; 2，其中$1表示第一个临时变量。 如果输出我们刚才用文本编辑器输出的内容呢？ 我们再用它创建一个方法，方法具体是什么我们后面再详细说，现在先简单的看效果 如果想修改方法，怎么办？重写吗？不用这样的亲，可以输入“/edit sum”，会弹出编辑界面： 调用修改过的方法，这里的j是我们定义的变量，所以它没有”$”符号。 如果我们想看看之前自己所运行的所有脚本，我们可以用“/list”来查看 然后，我们可以通过“/import”来查看脚本的默认导入的包，至于什么是包，就是当前程序运行需要引用的一些东西 最后，我们输入“/exit”来退出jshell环境： 结语好啦，两种方式都介绍完了，赶紧去尝试一下吧！","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】03-Java开发环境配置","slug":"【JavaSe必知必会】03-Java开发环境配置","date":"2018-11-15T02:00:34.000Z","updated":"2018-11-19T10:25:32.270Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】03-Java开发环境配置/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】03-Java开发环境配置/","excerpt":"","text":"前言在上一篇文章对Java做了一个简单介绍之后，我想大家都已经对她有一个初步的认识了吧！那踏入正式学习使用Java之前，我们有一步是不得不做的，它是什么呢？没有错，就是我们本篇文章的标题所说，搭建Java的开发环境配置。那我们就正式进入主题吧！ JDK的下载与安装JDK下载 通过官方网站获取JDKhttp://www.oracle.com 针对不同操作系统，下载不同的JDK版本识别计算机的操作系统下载图解 浏览器访问==Oracle==官网：http://www.oracle.com 标注1：浏览器输入==Oracle==官网地址（回车） 标注2：点击==Java==选项 标注3：选择==Java SE==选项（等待跳转新页面） 找到Java开发平台，访问链接 标注1：选择==Technologies==（技术）选项 标注2：选择==Java SE==选项 标注3：点击==Java Platform, Standard Edition==链接 选择自己想要的JDK版本，进入下载页面 标注1：选择==Download==选项 标注2：点击==JDK==下的==DOWNLOAD==按钮（选择自己想要下载的JDK版本） 选择想要下载的版本号进行下载（这里选择==Jdk8==的==8u162==） 标注1：选择接受版本协议（必选） 标注2：根据自己的==操作系统位数==选择对应版本进行下载Windows操作系统位数查看 回到桌面，找到==我的电脑==–&gt;==鼠标右键==–&gt;==属性== 标注1：操作系统位数（图片显示的是64位操作系统） JDK安装 找到之前下载的JDK安装文件 标注1：该文件即为java安装可执行文件 双击该文件执行安装，弹出如下图： 标注1：点击下一步 定制安装弹窗： 标注1：选择==开发工具== 标注2：更改到自己想要存放的文件目录 标注3：点击下一步 等待进度条加载完成（此过程中不要进行任何操作） 安装==Jre== 标注1：把Jre的安装目录更改成和之前Jdk的同级目录 标注2：点击下一步 等待安装进度条执行完 弹出安装成功窗口 标注1：直接点击关闭即可验证安装结果 标注1：DOS窗口命令行输入：==java==，回车，展示如上图片内容则安装成功JDK目录介绍 bin：JDK的各种工具命令即JDK开发工具的可执行文件其中这些可执行文件都是二进制的 db：jdk自带数据库 include：一些供C语言使用的标题文件 jre：运行Java程序所必须的JRE环境 lib：支持Java运行的核心类库 src：Java所有核心类库的源代码环境变量配置 环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。 找到我的电脑，点击鼠标右键，选择属性，弹出如下窗口 标注1：点击==高级系统设置== 点击环境变量按钮 标注1：环境变量按钮 点击==环境变量==下的==新建按钮== 新建==JAVA_HOME==变量 标注1：变量名为“JAVA_HOME”(复制我引号内的内容就可以了，不含引号） 标注2：变量值，必须是自己装jdk时的路径 标注3：设置完成点击确定按钮 找到“CLASSPATH”,没有的话就“新建” 标注1：变量名为“==CLASSPATH==”(复制我引号内的内容就可以了，不含引号） 标注2：变量值“==.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;==”(不含引号） 标注3：设置完成点击确定按钮 找到Path，对其进行编辑 标注1：==%JAVA_HOME%\\bin== 标注2：==%JAVA_HOME%\\jre\\bin== 标注3：设置完成点击确定按钮，把之前窗口的所有确定按钮都点击验证方式 任意窗口下打开Dos窗口，输入命令==javac==，看是否输出如下图所示内容，有则配置成功","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】02-Java语言概述","slug":"【JavaSe必知必会】02-Java语言概述","date":"2018-11-15T02:00:15.000Z","updated":"2018-11-19T10:25:32.267Z","comments":true,"path":"2018/11/15/【JavaSe必知必会】02-Java语言概述/","link":"","permalink":"http://yoursite.com/2018/11/15/【JavaSe必知必会】02-Java语言概述/","excerpt":"","text":"前言在看完了上一篇文章的计算机基础的文章后，我想大家应该对常用的计算机基础知识有一定的了解了吧！那我们就正式开始Java语言的学习之旅吧！ Java语言发展历史Java语言之父Java之父——詹姆斯·高斯林出生于加拿大，是一位计算机编程天才。在卡内基·梅隆大学攻读计算机博士学位时，他编写了多处理器版本的Unix操作系统，是JAVA编程语言的创始人。 名号由来1991年，在Sun公司工作期间，高斯林和一群技术人员创建了一个名为Oak的项目，旨在开发运行于虚拟机的编程语言，同时允许程序在电视机机顶盒等多平台上运行。后来，这项工作就演变为Java。随着互联网的普及，尤其是网景开发的网页浏览器的面世，Java成为全球流行的开发语言。++因此被人称作Java之父。++ 职业生涯 1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视，后来转至Sun公司。 1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。 在2010年甲骨文收购Sun后不久，这位Java编程语言的发明者宣布离职，并在2011年初加入谷歌。 2011年8月30日，高斯林在其博客上宣布离开谷歌，加入开展海洋探测业务的机器人制造公司Liquid Robotics，任首席软件架构师。负责传感器软件开发和自主导航设计，数据中心海量数据处理。 Java发展历史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字”2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME 2006年12月，SUN公司发布JRE6.0 2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。 2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP[4]。 2011年7月28日，甲骨文发布java7.0的正式版。 2014年3月18日，Oracle公司发表Java SE 8。 2017年9月22日，Oracle公司发表Java SE 1.9。Java语言平台版本 J2SE(Java 2 Platform Standard Edition)标准版 是为开发普通桌面和商务应用程序提供的解决方案 该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发 J2ME(Java 2 Platform Micro Edition)小型版 是为开发电子消费产品和嵌入式设备提供的解决方案 J2EE(Java 2 Platform Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案 该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字”2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。 Java语言特点 简单性 解释性 面向对象 高性能 分布式处理 多线程 健壮性 动态 结构中立 安全性 ==开源== ==跨平台==跨平台性 什么是跨平台性？ 通过Java语言编写的应用程序在不同的系统平台上都可以运行。 原理是什么？ 只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。 ==++Java语言是跨平台的，而JVM不是跨平台的++。== JRE与JDKJRE（Java Runtime Environment）JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。 JDK（Java Development Kit ）JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo。 为什么JDK中包含一个JRE呢？ 其一，开发完的程序，总需要运行一下看看效果。 其二，也是最重要的，JDK中的开发工具其实都是java语言编写的应用程序，为了方便使用才打包成exe文件，如果没有JRE，那么这些工具是运行不了的。 选择Java的原因持续的超高热度 上图是来自权威的TIOBE排行榜 可以看出，Java有着超高的热度，这意味着Java前景好、就业面广。 使用广泛java拥有庞大的用户，活跃的社区，语言稳定，能让你在遇到问题的时候快速找到解决方案。Java有很多企业在用，而且都是用在大项目上，这意味着java有良好的就业环境。 简单易学首先Java是一个面向对象的编程语言，容易理解。而且略去了多重加载、指针等难以理解的概念。并且实现了自动垃圾回收，大大简化了程序设计。而且网上关于java的学习资源太多太多了，如雨后春笋般冒出来的java培训机构也太多太多了，这都给我们提供了一个很好的学习环境与氛围。 丰富的类库Java从出道至今已有10多年的历史，经过10多年的积累和沉淀，出现了很多优秀的开源社区，如Apache和Spring。这些优秀的社区提供了很多非常好的框架，借助这些框架可以使我们不用去关注Java底层的开发，而只需关注业务的实现。 多样的职业发展路径 其实图片中包括的并不是特别准确，当下行情比上述描述的还要好，薪资其实比上面要更高，职业发展路径选择的方式也大于上图所示。但前提是，学好的情况下！ 结语听我说了这么多，是不是已经迫不及待的想要投入Java的怀抱了？还等什么，快上车，不然来不及了！","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"【JavaSe必知必会】01.计算机基础","slug":"【JavaSe必知必会】01-计算机基础","date":"2018-11-14T03:00:35.000Z","updated":"2018-11-14T03:41:31.261Z","comments":true,"path":"2018/11/14/【JavaSe必知必会】01-计算机基础/","link":"","permalink":"http://yoursite.com/2018/11/14/【JavaSe必知必会】01-计算机基础/","excerpt":"","text":"前言我想，来到这的朋友肯定是想学习JAVA或者想要进入IT这个行业的。考虑到大家的基础可能不一样，有些人可能还是用着新买的电脑，为了让大家在后续的学习中更加顺畅。在学习一门全新的计算机语言之前，我需要先给大家普及了解一些计算机基础知识。 计算机基础知识计算机 计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。 计算机的应用已渗透到社会的各个领域，正在改变着人们的工作、学习和生活的方式，推动着社会的发展。哪些方面?归纳一下，计算机的应用主要在以下几个方面： 1：科学计算 科学计算也称数值计算。计算机最开始是为解决科学研究和工程设计中遇到的大量数学问题的数值计算而研制的计算工具。例如，人造卫星轨迹的计算，房屋抗震强度的计算，火箭、宇宙飞船的研究设计都离不开计算机的精确计算。就连我们每天收听收看的天气预报都离不开计算机的科学计算。 2、数据处理 在科学研究和工程技术中，会得到大量的原始数据，其中包括大量图片、文字、声音等信息处理就是对数据进行收集、分类、排序、存储、计算、传输、制表等操作。 3、自动控制 自动控制是指通过计算机对某一过程进行自动操作，它不需人工干预，能按人预定的目标和预定的状态进行过程控制。例如，无人驾驶飞机、导弹、人造卫星和宇宙飞船等飞行器的控制，都是靠计算机实现的。 4、计算机辅助设计计算机辅助设计(Computer Aided Design，简称CAD)是指。借助计算机的帮助，人们可以自动或半自动地完成各类工程设计工作。目前CAD技术已应用于飞机设计、船舶设计、建筑设计、机械设计、大规模集成电路设计等。在京九铁路的勘测设计中，使用计算机辅助设计系统绘制一张图纸仅需几个小时，而过去人工完成同样工作则要一周甚至更长时间。可见采用计算机辅助设计，可缩短设计时间，提高工作效率，节省人力、物力和财力，更重要的是提高了设计质量。 5、人工智能 人工智能(Artificial Intelligence，简称AI)是指计算机模拟人类某些智力行为的理论、技术和应用。例如，用计算机模拟人脑的部分功能进行思维学习、推理、联想和决策，使计算机具有一定“思维能力”。我国已开发成功一些中医专家诊断系统，可以模拟名医给患者诊病开方。 还有就是机器人也是计算机人工智能的典型例子。 6、多媒体应用 随着电子技术特别是通信和计算机技术的发展，人们已经有能力把文本、音频、视频、动画、图形和图像等各种媒体综合起来，构成一种全新的概念—“多媒体”(Multimedia)。比如一些flash广告，网页游戏等。 7、计算机网络 计算机网络是由一些独立的和具备信息交换能力的计算机互联构成，以实现资源共享的系统。如在全国范围内的银行信用卡的使用，火车和飞机票系统的使用等。 计算机硬件计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。计算机通常由CPU、主板、内存、电源、主机箱、硬盘、显卡、键盘、鼠标，显示器等多个部件组成。 计算机软件计算机软件是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能，计算机软件按照其功能划分为系统软件与应用软件 系统软件： DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS 应用软件：office QQ聊天 YY语言 扫雷 软件开发 软件按照特定顺序组织的计算机数据和指令的集合 开发软件的制作过程 软件开发借助开发工具与计算机语言制作软件 计算机语言 语言 人类进行沟通交流的各种表达符号，方便人与人之间进行沟通与信息交换 计算机语言 人与计算机之间进行信息交流沟通的一种特殊语言计算机语言中也有字符，符号等等常见的计算机语言如C,C++,C#,JAVA 人机交互方式 软件的出现实现了人与计算机之间更好的交互。 交互方式 图形化界面：这种方式简单直观，使用者易于接受，容易上手操作。 命令行方式：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。 键盘功能键及快捷键介绍键盘功能键介绍 Tab Shift Ctrl Alt 空格 Enter Window 上下左右 PrtSc(PrintScreen)屏幕截图 快捷键介绍 Ctrl+A 全选 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+X 剪切 Ctrl+Z 撤销 Ctrl+S 保存 常用的DOS命令打开DOS控制台的方式 开始–程序–附件–命令提示符 开始–运行—cmd—回车 win+r—cmd–回车 扩充内容：目录中的exe文件可以直接使用其名称执行该命令调整DOS界面显示内容数量 常用DOS命令 d: 回车 盘符切换 dir(directory):列出当前目录下的文件以及文件夹 md (make directory) : 创建目录 rd (remove directory): 删除目录 cd (change directory)改变指定目录(进入指定目录) cd.. : 退回到上一级目录 cd\\: 退回到根目录 del (delete): 删除文件,删除一堆后缀名一样的文件*.txt exit : 退出dos命令行 cls : (clear screen)清屏","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]}]}